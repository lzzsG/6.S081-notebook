---
layout: page
title: L14 File Systems
permalink: /L14
description: "Lecture 14 - File Systems，文件系统是操作系统中除Shell之外最常见的用户接口。用户日常操作计算机时，文件系统是不可或缺的一部分。通过对文件系统的学习，了解其背后的原理和实现方法，有助于更深刻地理解操作系统的整体设计。"
nav_order: 14




---

# Lecture 14 - File Systems

## 文件系统概述与XV6对比

### 文件系统的重要性

文件系统是操作系统中除Shell之外最常见的用户接口。用户日常操作计算机时，文件系统是不可或缺的一部分。通过对文件系统的学习，了解其背后的原理和实现方法，有助于更深刻地理解操作系统的整体设计。

### 文件系统的核心特性

1. **用户友好的文件名与路径**：
   - 文件系统允许使用层级路径名来组织文件，这使得用户能够以逻辑方式组织和管理文件。这种结构化路径不仅方便了文件的查找和管理，也使得在用户与进程之间共享文件变得更加容易。

2. **持久化存储**：
   - 文件系统提供了持久化功能，这意味着文件在计算机重启后依然保留。这一点使得文件系统区别于其他资源管理子系统，如进程管理，它们在系统重启后需要重新初始化，而文件系统则能保证数据的持久性。

### XV6文件系统与现代文件系统的异同

1. **文件大小与文件名限制**：
   - XV6文件系统对支持的文件大小有较为严格的限制，相比之下，现代文件系统支持的文件尺寸更大。此外，XV6对文件名的长度也有限制，而现代文件系统通常支持更长、更灵活的文件名。

2. **缺少高级特性**：
   - XV6文件系统缺少一些现代文件系统中的高级特性，例如`copy-on-write`（写时复制）技术，这种技术可以有效地减少数据写入时的资源消耗。

3. **基本结构的相似性**：
   - 尽管在功能上有所不同，XV6文件系统与现代文件系统在基本结构上仍然相似。它们都采用了文件名、inode（索引节点）、目录等基本概念，并且文件目录的结构都是层级式的。
4. ...

## 文件系统的内部机制与关键概念

在接下来的课程中，我们将深入探讨文件系统的内部工作原理。文件系统之所以有趣，主要有以下几个原因：

### 1. 文件系统对硬件的抽象

   - **硬件抽象的实现**：文件系统通过对硬件的抽象，使得用户和应用程序可以方便地与底层存储设备进行交互，而无需关心具体的硬件细节。理解这一抽象层的实现方式对于深入理解操作系统的设计有重要意义。

### 2. 崩溃安全性（Crash Safety）

   - **崩溃恢复能力**：文件系统在执行过程中，可能会遇到计算机崩溃的情况。在这种情况下，崩溃安全性能够确保文件系统在重启后仍然保持数据的完整性和一致性。如果文件系统在崩溃后无法恢复，用户的数据可能会丢失或损坏。因此，崩溃安全性是文件系统设计中的一个关键点，我们将在下节课中深入探讨这一主题。

### 3. 文件系统在磁盘上的布局

   - **磁盘数据结构**：文件系统的目录和文件在磁盘上需要以某种数据结构存在，这样才能在系统重启后恢复数据。XV6文件系统使用的磁盘数据结构较为简单，因为其目的是教学。然而，真实的文件系统通常会更为复杂，这些复杂的数据结构在磁盘上保存文件系统的结构和内容。今天的课程将重点探讨这些数据结构如何在磁盘上布局和组织。

### 4. 文件系统的性能优化

   - **硬件速度差异与性能优化**：存储设备的访问速度通常较慢，比如在SSD上写入数据的操作可能需要数毫秒，而在这段时间内，计算机可以执行大量的其他任务。因此，优化文件系统的性能非常重要。例如，文件系统通常使用缓冲缓存（buffer cache）或块缓存（block cache）来减少对磁盘的直接写入操作，从而提升整体性能。
   - **并发处理**：文件系统还需要处理多进程并发操作。例如，当一个进程正在查找路径名时，另一个进程可能在执行其他文件系统操作。如何有效管理这些并发操作是文件系统设计中的一个重要话题。

### 实验内容与文件系统的关联

接下来的实验内容将围绕文件系统展开：

- **Lab任务**：下一个实验（lab）将完全聚焦于文件系统的实现和优化。再下一个实验则会结合虚拟内存和文件系统进行综合练习。即使是本周的实验，也涉及到如何让缓冲缓存支持更多的并发操作。因此，深入理解文件系统不仅对理论学习有帮助，也直接影响到你们在实验中的实践表现。

## 文件系统相关系统调用与实现细节

在理解文件系统的功能和实现时，研究其提供的系统调用是至关重要的。通过这些系统调用的接口，我们可以推测出文件系统内部的一些设计细节。以下是与文件系统相关的一些关键系统调用及其背后机制的分析。

### 1. `open` 系统调用

**代码示例：**

```c
int fd = open("x/y", O_CREATE | O_RDWR);
```

- **功能**：在路径 `x/y` 下创建一个新文件，或打开已存在的文件，并返回一个文件描述符 `fd`。
- **分析**：
  - **路径名的可读性**：系统调用中的路径名是用户可读的字符串，而非硬件层面的数字地址，这意味着文件系统需要支持将用户输入的路径名解析为具体的存储位置。
  - **文件的偏移管理**：`open` 仅返回文件描述符，而文件偏移量（offset）并未作为参数传入。文件系统必须内部维护文件的当前偏移量，以便后续的 `write` 操作可以在正确的位置进行写入。

### 2. `write` 系统调用

**代码示例：**

```c
write(fd, "abc", 3);
```

- **功能**：将字符串 `"abc"` 写入到文件 `fd` 指向的文件中。
- **分析**：
  - **隐式文件偏移量**：`write` 系统调用没有显式提供偏移量。文件系统会在内部记录文件的当前偏移量，并在每次写入后自动更新这个值。
  - **并发写入的管理**：由于文件偏移量是在文件系统内部管理的，多线程或多进程的并发写入需要确保对偏移量的访问是线程安全的，避免数据竞争。

### 3. `link` 系统调用

**代码示例：**

```c
link("x/y", "x/z");
```

- **功能**：为已有文件 `x/y` 创建一个新的硬链接 `x/z`，即 `x/y` 和 `x/z` 两个路径名指向同一个文件。
- **分析**：
  - **引用计数管理**：文件系统需要跟踪同一个文件的多个文件名。这通常通过增加引用计数的方式来实现，每创建一个新的链接，引用计数加一。
  - **inode的管理**：`link` 操作直接在 inode 层面进行，而不是文件描述符层面。inode 是文件系统内部用来表示文件元数据的结构，每个文件对应一个唯一的 inode。

### 4. `unlink` 系统调用

**代码示例：**

```c
unlink("x/y");
```

- **功能**：删除路径名 `x/y`，使之不再指向任何文件。如果此文件的引用计数降为0，则文件将从磁盘中删除。
- **分析**：
  - **命名空间与文件对象的分离**：`unlink` 仅删除文件名与文件对象之间的映射关系，而不会影响已打开的文件描述符。即使路径名被删除，文件描述符依然可以继续操作该文件。这意味着文件系统需要在内部维护文件对象与文件名之间的独立性。

## 文件系统API与实现之间的关系

通过上述系统调用的API，我们可以推测出文件系统内部的一些设计和实现细节：

1. **路径名解析**：文件系统需要实现从路径名到具体存储位置（如 inode）的解析过程。这涉及到文件系统的目录结构和路径查找算法。
2. **文件偏移管理**：文件系统必须在内部维护每个打开文件的当前偏移量，以支持连续的读写操作。
3. **引用计数与inode管理**：文件系统需要维护每个文件的引用计数，以便在文件的引用数归零时正确地释放资源。同时，文件系统还必须在 inode 层面管理文件链接操作。
4. **文件对象的抽象**：文件系统内部必须将文件对象与其命名分离，以支持在文件名删除后仍然可以通过文件描述符访问文件。

### 文件系统的实现与其他存储系统的对比

值得注意的是，文件系统提供的API并不是唯一构建存储系统的方式。比如，数据库系统同样可以持久化存储数据，但其API与文件系统的API完全不同。早期数据库通常直接基于磁盘构建自己的文件系统，以提高性能并确保数据一致性（ACID属性）。然而，现代操作系统的文件系统已经足够强大，绝大多数现代数据库都建立在操作系统自带的文件系统之上。

> **硬链接与软链接**：硬链接 (`link`) 直接操作 inode，而软链接（将在下一个实验中实现）是指向文件路径的符号链接。硬链接与文件对象直接关联，而软链接则是一个独立的文件，存储了目标文件的路径信息。



## 文件系统的结构与核心数据结构

为了实现前面介绍的各种文件系统API，文件系统内部必须维护一系列复杂的数据结构。接下来，我们将重点介绍这些结构是如何组织的，以及它们如何协同工作以支持文件系统的功能。

### 1. **inode（索引节点）**

   - **inode的作用**：在文件系统中，`inode` 是一个代表文件的对象，它不依赖于文件名。每个 `inode` 都有一个唯一的编号（整数），文件系统内部通过这个编号来引用和管理文件，而不是通过路径名。
   - **link count**：`inode` 还必须维护一个 `link count`，用于跟踪指向该 `inode` 的文件名的数量。只有当 `link count` 为0时，文件才能被删除。
   - **openfd count**：此外，`inode` 还需要维护一个 `openfd count`，即当前打开的文件描述符的数量。只有当 `link count` 和 `openfd count` 都为0时，文件才会被从磁盘上删除。

```
+------------------------------+
|          inode               |
|  +------------------------+  |
|  | inode number (ID)      |  |  // Unique identifier for the file
|  +------------------------+  |
|  +------------------------+  |
|  | link count             |  |  // Tracks the number of links to this inode
|  +------------------------+  |
|  +------------------------+  |
|  | openfd count           |  |  // Tracks the number of open file descriptors
|  +------------------------+  |
+------------------------------+

```




### 2. **文件描述符（File Descriptor）**

   - **offset管理**：每个文件描述符（`file descriptor`）与用户进程交互，并隐式地维护了一个文件的偏移量（`offset`）。当进行 `read` 或 `write` 操作时，文件系统会自动更新这个偏移量，以确保数据被正确地写入或读取。
   - **文件描述符与inode的关联**：文件描述符本质上是用户访问文件的接口，而 `inode` 是文件在文件系统内部的表示形式。文件描述符通过 `inode` 访问文件的实际数据。

```
+------------------------------+
|      File Descriptor         |
|  +------------------------+  |
|  | File Descriptor ID     |  |  // Handle used by user process
|  +------------------------+  |
|  +------------------------+  |
|  | File Offset            |  |  // Maintains the current read/write position
|  +------------------------+  |
|  +------------------------+  |
|  | Pointer to inode       |  |  // Points to the inode for actual file data
|  +------------------------+  |
+------------------------------+

```




### 3. **文件系统的分层结构**

   文件系统的实现通常非常复杂，为了更好地理解这些复杂性，我们可以采用分层的方式来分析文件系统的结构。这种分层结构帮助我们从概念上理解文件系统的各个组件是如何协同工作的。

   - **磁盘层**：这是最底层，负责实际的数据存储。磁盘提供了持久化存储功能。
   - **缓冲缓存（Buffer Cache）/块缓存（Block Cache）**：位于磁盘之上，缓冲缓存用来减少对磁盘的直接访问，提升性能。数据从磁盘读取后，通常会被暂时保存在缓存中，以便快速访问。
   - **日志记录层（Logging Layer）**：在缓冲缓存之上，许多文件系统都会有日志记录机制，用于保证系统的持久性和一致性。通过日志记录，可以在系统崩溃后恢复未完成的文件操作。我们将在下节课深入讨论这个层次。
   - **inode缓存层**：在XV6中，为了实现同步操作，系统维护了 `inode` 缓存。多个 `inode` 通常打包在一个磁盘块中，因此 `inode` 缓存帮助我们在操作单个 `inode` 时实现同步。
   - **inode层**：这个层次直接负责文件的 `read` 和 `write` 操作，是文件系统的核心部分之一。
   - **路径名和文件描述符层**：最上层是路径名解析和文件描述符操作。路径名用于用户定位文件，文件描述符则是用户与文件系统交互的主要方式。

```
  +----------------------------------------+
  |  Pathname & File Descriptor Layer      |
  |  - Pathname resolution                 |
  |  - File Descriptor operations          |
  +----------------------------------------+
  |            inode Layer                 |
  |  - Handles read/write operations       |
  +----------------------------------------+
  |           inode Cache Layer            |
  |  - Synchronize & optimize inode access |
  +----------------------------------------+
  |          Logging Layer                 |
  |  - Ensure system durability            |
  +----------------------------------------+
  |         Buffer/Block Cache Layer       |
  |  - Reduce disk I/O                     |
  +----------------------------------------+
  |           Disk Layer                   |
  |  - Persistent storage devices          |
  |  - Data blocks, metadata blocks, etc.  |
  +----------------------------------------+
```


### 4. **文件系统实现的灵活性**

   - **不同文件系统的差异**：尽管大多数文件系统都会有类似的结构和分层，但实现细节可能会有所不同。有些文件系统在某些层次上可能会合并，或者采用不同的优化策略。例如，在某些文件系统中，缓存机制或日志机制可能会更为复杂或定制化。
   - **分层的意义**：尽管分层在实际实现中并不总是严格的，但从概念上理解这些层次对于掌握文件系统的工作原理非常有帮助。无论文件系统如何实现，它们通常都会涉及到缓存、日志、`inode` 和路径名解析等核心组件。



## 存储设备概述

在文件系统的最底层，是各种类型的存储设备。虽然有许多不同类型的存储设备，但我们主要关注两种最常见的类型：**SSD（固态硬盘）**和**HDD（机械硬盘）**。这两种存储设备尽管在性能上有显著差异，但它们都以合理的成本提供了大量的存储空间。

### 1. **SSD与HDD的性能对比**

   - **SSD（Solid State Drive）**：
     - 访问时间通常在 **0.1到1毫秒** 之间。
     - 通过闪存技术存储数据，速度快，但成本相对较高。

   - **HDD（Hard Disk Drive）**：
     - 访问时间通常在 **10毫秒** 量级。
     - 使用磁性材料的旋转盘片存储数据，较慢但成本较低。

### 2. **术语解释：Sectors与Blocks**

   - **Sector**：
     - 是磁盘驱动器可以读写的最小单元，通常为 **512字节**。

   - **Block**：
     - 是操作系统或文件系统视角的数据单元，大小由文件系统定义。**在XV6中，一个block是1024字节**，因此一个block通常对应两个sector。

 有时候，磁盘上的sector也被称为block，这使得术语使用上可能不太精确。

### 3. **存储设备与计算机的连接**

存储设备（如SSD和HDD）通过计算机的总线连接到CPU和内存。文件系统运行在CPU上，管理内存中的数据，同时通过读写block的形式与存储设备进行交互。存储设备的接口通常非常简单，主要包括 `read` 和 `write` 操作，通过block编号来指定读写位置。



### 4. **硬件抽象与驱动程序**

尽管SSD和HDD在内部工作原理上有很大不同，但硬件抽象屏蔽了这些差异。磁盘驱动程序通常使用标准协议（如PCIe）与存储设备交互。从文件系统的角度看，不同的存储设备在编程接口上看起来几乎一样——你可以通过提供block编号、控制寄存器读写等方式来与设备进行通信。

无论存储设备的底层机制如何不同，文件系统通过统一的抽象层与这些设备进行交互，使得编程更加简便和一致。

> **同步/异步接口**：磁盘驱动程序与之前讲的console的驱动类似，都是通过发送命令开始读写操作，并在操作完成后产生中断通知。然而，由于磁盘设备的复杂性，磁盘驱动程序的实现通常比console的驱动更复杂，但它们的代码结构仍然是相似的，包括底层的控制和中断处理部分。

## 文件系统视角下的磁盘结构

从文件系统的角度来看，磁盘可以被抽象为一个巨大的block数组，这个数组的索引从0开始，一直到磁盘的最后一个block。文件系统的工作就是将所有需要的文件数据和元数据以一种能够在系统重启后重新构建文件系统的方式存放在这个磁盘上。

### 1. **磁盘的block布局**

   - **Block 0**：通常是保留的，或者被用作 **boot sector**，用于启动操作系统。
   - **Block 1**：称为 **super block**，描述文件系统的整体信息，比如文件系统包含多少个block等。XV6的super block中还包含了更多的元数据信息，可以通过它重建大部分的文件系统结构。
   - **Block 2-31**：在XV6中，这些block用于 **log**（日志）。日志用于记录文件系统的操作，以保证崩溃恢复的完整性。日志的大小由super block定义，在XV6中通常是30个block。
   - **Block 32-45**：这些block存储了文件系统的 **inode**。每个inode大小为64字节，多个inode被打包在一个block中。
   - **Block 46**：存储 **bitmap block**，用于记录数据block的使用状态（空闲或已用）。
   - **Block 47及以后**：这些是 **数据block**，用于存储文件的内容和目录的数据。

   ```plaintext
+-----------------------------------------------------------------------------------------+
|  Block 0   |  Block 1  |  Block 2-31   |  Block 32-45  |  Block 46    | Block 47+   ... |
| Boot Block | Superblock|  Log Blocks   |  inode Blocks | Bitmap Block | Data Blocks     |
+-----------------------------------------------------------------------------------------+
   ```

### 2. **元数据block**

   - **Metadata Blocks**：通常，`bitmap block`，`inode blocks` 和 `log blocks` 被统称为元数据block（metadata blocks）。这些block虽然不存储实际的文件数据，但它们保存了对文件系统进行管理和维护所需的重要信息。

### 3. **inode在磁盘上的定位**

由于每个inode大小为64字节，因此多个inode可以存储在一个block中。为了找到某个特定inode在磁盘上的位置，可以使用以下计算公式：

### 计算公式

- **inode 所在的 block**:`block number = start block + (inode number * inode size) / block size`

- **inode 在 block 中的偏移量**: `offset = (inode number * inode size) % block size`


### 给定条件

- **inode 大小**: 64 字节
- **block 大小**: 1024 字节
- **inode 起始 block**: 32

### 示例

**读取 inode10 的位置：**

1. **计算 inode10 所在的 block**:
   - `block number = 32 + (10 * 64) / 1024`
   - `block number = 32 + 640 / 1024`
   - `block number = 32 + 0`  (因为 640 小于 1024)
   - **inode10 在 block 32**

2. **计算 inode10 在 block32 中的偏移量**:
   - `offset = (10 * 64) % 1024`
   - `offset = 640 % 1024`
   - `offset = 640`
   - **inode10 在 block 32 的偏移量为 640 字节**

这个计算方法可以让我们准确定位磁盘上任何 `inode` 的存储位置，只要我们知道 `inode` 编号，就可以找到它在磁盘上的位置和偏移量。

   ```plaintext
+-------------------------------------------------------------+
| Block 32 (inodes 0-15) | Block 33 (inodes 16-31) | ...      |
+-------------------------------------------------------------+
   ```

### 4. **XV6与QEMU的启动**

   - **Boot Block**：通常，boot block包含启动操作系统所需的初始代码。系统启动后，操作系统的进一步加载和初始化将从文件系统中完成。
   - **XV6在QEMU中的特殊处理**：在QEMU中运行XV6时，使用了简化的启动过程。QEMU可以直接从命令行加载内核镜像文件，并将其加载到物理内存的 `0x80000000` 地址。这种方式跳过了从虚拟磁盘读取boot sector的步骤。

## 磁盘上存储的 inode 结构

在文件系统中，`inode` 是一个关键的数据结构，它描述了文件的元数据以及文件数据在磁盘上的存储位置。在 XV6 中，`inode` 是一个 64 字节的结构体，其具体组成如下：

### inode 的组成部分

1. **type 字段**：

   - 指定 `inode` 是文件、目录还是其他类型。

2. **nlink 字段**：

   - 也称为链接计数器（link count），跟踪有多少文件名指向当前的 `inode`。当 `nlink` 变为 0 时，文件就可以被删除。

3. **size 字段**：

   - 表示文件的大小（以字节为单位）。

4. **direct block numbers（直接块编号）**：

   - XV6 的 `inode` 中包含 12 个直接块编号（block numbers），分别指向文件的前 12 个数据块。这些数据块包含了文件的实际内容。
   - 例如，如果文件只有 2 个字节，那么只会使用第一个直接块编号（block number 0），它指向磁盘上存储文件的 2 个字节的那个一个块。

5. **indirect block number（间接块编号）**：

   - 除了 12 个直接块编号之外，`inode` 还包含一个间接块编号。这是一个指向磁盘上另一个块的指针，该 block 内包含 256 个块编号，每个编号指向文件的一个数据块。这些数据块存储了文件的更多内容。

   **inode 结构示意图：**

   ```plaintext
     +---------------------------------+
     |        inode (64 bytes)         |
     +---------------------------------+
     | type       | 表示文件类型         |
     +---------------------------------+
     | nlink      | 链接计数器           |
     +---------------------------------+
     | size       | 文件大小（字节）      |
     +---------------------------------+
     | direct block number 0           |
     +---------------------------------+
     | direct block number 1           |
     +---------------------------------+
     | ...                             |
     +---------------------------------+
     | direct block number 11          |
     +---------------------------------+
     | indirect block number           |
     +---------------------------------+
   ```

### 文件最大长度的计算

在 XV6 中，由于 `inode` 结构的限制，文件的最大长度可以通过以下公式计算：

**最大文件长度 = (12 * block size) + (256 * block size)**

- **12 个直接块**：每个块大小为 1024 字节（1KB）。
- **256 个间接块**：每个块包含 256 个块编号，每个块大小为 1024 字节。

**最大文件长度 = (12 * 1024) + (256 * 1024) = 12 KB + 256 KB = 268 KB**

这是 XV6 中文件的最大长度，为 268KB。尽管这个大小在现代文件系统中显得很小，但 XV6 的设计基于早期 Unix 系统，其文件大小限制与之类似。

### 扩展 inode 结构以支持更大的文件

为了支持更大的文件，可以扩展 `inode` 结构，增加双重或多重间接块。例如：

- **双重间接块**：指向一个块，这个块包含 256 个间接块编号，每个间接块编号又指向一个包含 256 个直接块编号的块。这样，文件的最大长度可以达到 256 * 256 * 1KB = 64MB。

这种设计类似于多级页表，可以大幅度增加文件系统能够支持的文件大小。你将在接下来的实验中实现这一功能。

### 读取文件特定字节的步骤

假设需要读取文件的第 8000 个字节，我们可以通过以下步骤来确定如何从磁盘上读取该字节：

1. **确定文件的块编号**：
   - 文件的每个块大小为 1024 字节（1KB）。
   - 计算块编号：`8000 / 1024 = 7`，所以第 8000 个字节在文件的第 7 个块中。
   - 由于 7 小于 12，因此该块是 `inode` 中的第 7 个直接块编号所指向的块。

2. **计算块内的字节偏移量**：
   - 计算偏移量：`8000 % 1024 = 832`，所以第 8000 个字节在第 7 个块内的偏移量为 832 字节。

### inode 与 read/write 系统调用

通过 `inode` 中的信息，文件系统可以准确地定位文件的数据块，从而实现 `read` 和 `write` 系统调用。至少在简单情况下，`inode` 提供的信息足以查找文件的相关磁盘块并执行读取或写入操作。

## 目录结构与路径名查找

在文件系统中，目录（directory）是实现层次化命名空间（hierarchical namespace）的关键元素。目录允许用户组织文件和子目录，并使用对用户友好的名称进行访问。大多数 Unix 文件系统中的目录本质上是一个文件，它包含了文件系统能够理解的结构。在 XV6 中，目录的结构非常简单。

### 1. 目录结构

在 XV6 中，每个目录包含若干个目录项（directory entries），每个目录项的格式固定，总共占用 16 个字节：

- **前 2 个字节**：存储文件或子目录的 `inode` 编号。
- **接下来的 14 个字节**：存储文件或子目录的名称。

**目录项结构示意图：**

```plaintext
+------------------------+-------------------------------+
| inode number (2 bytes) |        Name (14 bytes)        |
+------------------------+-------------------------------+
```

### 2. 路径名查找的实现

在文件系统中，路径名查找是将路径名解析为文件或目录的 `inode` 编号的过程。我们通过一个例子来说明路径名查找的具体步骤。假设我们要查找路径名 `"/y/x"`，路径名查找的过程如下：

1. **从根目录开始**：
   - 路径名 `"/y/x"` 指示我们需要从根目录开始查找。根目录的 `inode` 编号通常是固定的，在 XV6 中，这个编号是 `1`。
   - 根据 `inode` 编号，文件系统可以确定根目录 `inode` 在磁盘上的位置。具体来说，`inode` 存储在从 `block 32` 开始的区域。`inode 1` 位于 `block 32` 中的 `64` 到 `128` 字节的位置。

2. **读取根目录的 `inode` 内容**：
   - 读取根目录的 `inode` 后，文件系统会扫描根目录 `inode` 对应的所有数据块，以查找名称为 `"y"` 的目录项。
   - 文件系统需要读取根目录的所有直接块编号（direct block numbers）和间接块编号（indirect block numbers）来查找目录项。

3. **查找子目录 `y`**：
   - 如果找到了 `"y"` 对应的目录项，那么它会包含子目录 `y` 的 `inode` 编号（假设为 `251`）。
   - 然后，文件系统将读取 `inode 251` 的内容，并扫描其对应的所有数据块，查找名称为 `"x"` 的目录项。

4. **返回查找结果**：
   - 找到 `"x"` 对应的 `inode` 编号后，路径名查找结束，返回该 `inode` 编号。

### 3. 目录和文件的区分

在路径名查找过程中，文件系统需要区分 `inode` 是目录还是文件。这是通过 `inode` 中的 `type` 字段实现的。

- **`type` 字段**：`inode` 的 `type` 字段表明这是一个目录还是一个文件。
- 如果试图对一个文件类型的 `inode` 进行路径名查找，文件系统会返回错误，因为文件不能作为目录进行进一步查找。

### 目录查找的效率

在 XV6 中，目录项的查找是通过线性扫描完成的。这种方式虽然简单，但当目录中的文件和子目录数量增加时，查找效率会显著下降。现代文件系统通常使用更复杂的数据结构（如 B 树、哈希表）来加速路径名查找，从而提高查找效率。

然而，XV6 采用了这种简单的结构，目的是为了保持设计的简洁性，并便于解释和理解。尽管这种方法在性能上有所妥协，但它有效地展示了文件系统的基本工作原理。

