## 回顾：用户态和内核态之间的切换

在XV6中，从用户态进入内核态的过程可以由系统调用（如`ecall`）或中断（如定时器中断）触发。无论是哪种情况，进入内核态和返回用户态的流程都涉及相似的步骤。

### **1. 触发条件**

- **系统调用（`ecall`）**：
  - 用户进程在用户态执行`ecall`指令，请求内核提供某种服务（如`sleep`、文件操作、进程管理等）。
  - `ecall`指令导致处理器进入内核态，并触发软中断。

- **中断（如定时器中断）**：
  - 用户进程在用户态正常执行时，硬件定时器达到设定时间，触发定时器中断。
  - 定时器中断是一种硬件中断，它强制处理器进入内核态。

### **2. 进入内核态：从用户态到`usertrap`**

- **进入`uservec`**：
  - 无论是系统调用还是硬件中断，处理器在进入内核态后，都会首先跳转到`trampoline.S`中的`uservec`代码。`stvec`寄存器被设置为指向`uservec`。
  - `uservec`的主要任务是将当前用户进程的寄存器状态保存到该进程的`trapframe`中。具体地，它会保存`ra`（返回地址）、`sp`（栈指针）、`s0-s11`（保存寄存器）、`t0-t6`（临时寄存器）等。

- **跳转到`usertrap`**：
  - 寄存器状态保存到`trapframe`后，`uservec`将执行权交给`usertrap`函数。这个跳转是通过`jr t0`完成的，其中`t0`寄存器存储了`usertrap`函数的地址。
  - `usertrap`是核心的中断和系统调用处理函数。在`usertrap`中，根据`scause`寄存器的值，判断进入内核态的原因：
    - **系统调用**：如果`scause`的值为8，则是系统调用。`usertrap`会调用`syscall`函数来处理这个系统调用。
    - **其他中断**：例如定时器中断，则调用`devintr`函数来处理中断。

### **3. 在内核态处理**

- **系统调用的处理**：
  - `syscall`函数根据系统调用编号，从系统调用表中选择相应的处理函数（如`sys_sleep`、`sys_read`等）。
  - 处理完系统调用后，`syscall`函数会将结果存入`trapframe`的`a0`寄存器中（用于存储返回值）。

- **中断的处理**：
  - 如果是定时器中断，`devintr`函数会调用`clockintr`来处理定时器中断，可能会增加系统时钟计数`ticks`，并且触发进程调度。
  - 如果进程需要出让CPU，`usertrap`会调用`yield`函数进入调度流程，最终调用`sched`进行上下文切换。

### **4. 返回用户态：从`usertrapret`到用户代码**

- **调用`usertrapret`**：
  - 无论是系统调用还是中断处理完成后，`usertrap`都会调用`usertrapret`函数，准备返回用户态。
  - `usertrapret`设置好返回用户态时需要的上下文，包括将`stvec`重新设置为`uservec`，以及恢复用户态的`sepc`（程序计数器）和`sstatus`（状态寄存器）。

- **跳转到`userret`**：
  - 在`usertrapret`的最后，它调用了`trampoline.S`中的`userret`代码。`userret`的任务是从`trapframe`中恢复所有用户态的寄存器，并通过`sret`指令切换到用户态。
  - `sret`指令会恢复处理器状态并切换到用户模式，使用户进程继续从中断或系统调用前的地方执行。

### **5. 关键调用链**

- **进入内核态的过程**：
  1. 用户态代码（`ecall` 或 中断触发）
  2. 处理器进入内核态，跳转到 `uservec`
  3. `uservec` 保存寄存器状态到 `trapframe`
  4. `uservec` 跳转到 `usertrap`
  5. `usertrap` 处理系统调用或中断
     - 系统调用：`usertrap` -> `syscall` -> 对应系统调用函数
     - 中断：`usertrap` -> `devintr` -> 对应中断处理函数

- **返回用户态的过程**：
  1. `usertrapret` 恢复用户态上下文
  2. `usertrapret` 调用 `userret`
  3. `userret` 恢复寄存器状态，并通过 `sret` 切换到用户态
  4. 用户态代码继续执行

不论是系统调用还是中断，用户态到内核态的切换都是通过`trampoline.S`中的`uservec`来完成的，返回用户态的过程则通过`userret`和`sret`指令来完成。这一流程确保了用户态进程在内核态处理完系统调用或中断后，能够正确恢复并继续执行。

---

## 定时器中断引发的线程切换流程

定时器中断是操作系统实现预抢占调度的关键机制。以下是定时器中断引发线程切换的详细全流程，包括从定时器中断发生到内核调度器选择下一个进程的全过程。

1. **定时器中断触发**：
   - 当前进程正在用户态运行时，硬件定时器触发中断。
   - 定时器中断强制CPU从用户态切换到内核态，保存当前进程的用户态上下文并执行中断处理。
2. **进入`usertrap`之前的处理：`uservec`**：
   - CPU切换到内核态后，首先跳转到`trampoline.S`中的`uservec`代码段，这段代码是由`stvec`寄存器指定的。
   - `uservec`负责将当前用户态进程的所有寄存器状态保存到该进程的`trapframe`结构中，以便稍后能够恢复这些寄存器状态。
   - 保存完成后，`uservec`跳转到内核中的`usertrap`函数。
3. **进入`usertrap`函数，处理中断或异常**：
   - `usertrap`函数负责处理进入内核态后的中断。它会检查当前中断的原因，通过读取`scause`寄存器的值来判断具体的中断类型。
   - 如果是定时器中断或者其他外部中断，`usertrap`会调用`devintr`来处理中断。
4. **处理定时器中断，调用`yield`出让CPU**：
   - 如果中断类型为定时器中断（`devintr`返回2），则意味着可能需要进行进程调度。此时，`usertrap`会调用`yield`函数，让出CPU，从而允许调度器选择另一个进程运行。
5. **`yield`函数的执行**：
   - `yield`函数首先获取当前进程的锁`p->lock`，以确保接下来的操作是原子性的。
   - 将当前进程的状态从`RUNNING`设置为`RUNNABLE`，表示它已准备好再次被调度。
   - 然后调用`sched`函数来进行上下文切换，将CPU控制权让给内核调度器。
6. **`sched`函数的执行**：
   - `sched`函数检查进程的锁是否被持有，确保状态的一致性。
   - 调用`swtch`函数，将当前进程的上下文（寄存器状态等）保存到进程的`context`结构中。
   - `swtch`函数将CPU控制权切换到调度器线程（即调度器的上下文），完成当前进程的挂起。
7. **`swtch`函数：上下文切换**：
   - `swtch`函数保存当前进程的寄存器状态到其`context`中，然后恢复调度器线程的寄存器状态。
   - 调度器线程恢复执行，通过`scheduler`函数选择下一个可运行的进程。
8. **调度器线程的工作**：
   - 调度器线程在`scheduler`函数中遍历所有进程，找到一个`RUNNABLE`状态的进程。
   - 调度器将选定的进程状态设置为`RUNNING`，并通过`swtch`切换到该进程的上下文。
9. **恢复挂起的进程**：
   - `swtch`函数在恢复进程的上下文后，从上次挂起的位置继续执行进程的代码。
   - 进程是由于定时器中断而被挂起的，恢复后的进程将从`usertrap`函数的上下文中继续执行，最终通过`usertrapret`返回到用户态。
   - `usertrapret`通过调用`trampoline.S`中的`userret`，使用`sret`指令切换回用户态，使进程继续执行用户代码。

### **函数调用链**

- **进入中断处理**：
  1. 用户态：`user code`（定时器中断触发）
  2. 内核态：uservec -> `usertrap -> devintr -> clockintr -> usertrap -> yield -> sched -> swtch`

- **挂起和上下文切换**：
  1. 调度器：`swtch -> scheduler (choose another process) -> swtch`

- **恢复挂起进程**：
  1. 调度器：`swtch (restore context)`
  2. 继续执行：`sched ->  usertrapret -> userret -> user code`

---

## 系统调用（如 `sleep`）挂起引发的线程切换全流程

在XV6操作系统中，系统调用（如`sleep`）引发的线程切换涉及多个步骤。以下是详细的全流程描述，包括从用户进程发起系统调用，到内核进行调度的全过程。

### **流程详解**

1. **用户进程发起系统调用**：

   - 用户进程在用户态执行代码时，遇到需要执行系统调用的情况（如`sleep`）。
   - 用户进程通过`ecall`指令发起系统调用。`ecall`是RISC-V架构中的指令，用于从用户态进入内核态。

2. **进入内核态：保存用户态寄存器并跳转到`syscall`函数**：

   - `ecall`指令触发软中断，处理器切换到内核态。
   - 处理器首先跳转到`trampoline.S`中的`uservec`代码段，`uservec`负责将当前用户态的寄存器状态保存到进程的`trapframe`中。
   - 然后，`uservec`跳转到`usertrap`函数，`usertrap`函数识别出这是一个系统调用，并调用`syscall`函数。

3. **执行具体的系统调用处理（如`sleep`）**：
   - `syscall`函数根据`trapframe`中存储的系统调用编号，调用相应的内核函数（如`sleep`）。
   - 在这个例子中，`sys_sleep`函数根据传入的参数（如休眠时间）执行休眠操作，并判断进程是否需要等待。

4. **进程进入等待状态**：
   - `sleep`函数判断当前进程需要等待指定时间后再继续执行，因此将当前进程的状态设置为`SLEEPING`。
   - 为了让其他进程获得CPU，`sleep`函数会调用`yield`函数来出让CPU。

5. **`yield`函数的执行**：
   - 在`yield`函数中，进程首先获取自身的锁（`p->lock`），以确保在切换过程中进程状态不会被其他线程或中断干扰。
   - 将当前进程的状态从`SLEEPING`或`RUNNING`设置为`RUNNABLE`（视情况而定）。
   - 然后调用`sched`函数来进行调度。

6. **`sched`函数的执行**：
   - `sched`函数要求进程锁已经被持有，它检查锁的持有状态以防止不一致。
   - `sched`函数调用`swtch`函数，将当前进程的上下文（寄存器状态等）保存到该进程的`context`结构中。
   - `swtch`函数将CPU控制权切换到调度器线程，进程的执行被挂起。

7. **`swtch`函数：上下文切换**：
   - `swtch`函数保存当前进程的寄存器状态，并恢复调度器线程的寄存器状态。
   - 调度器线程恢复执行，选择其他可运行的进程。

8. **调度器线程选择下一个进程**：

   - 调度器线程通过`scheduler`函数选择下一个可运行的进程，并使用`swtch`切换到该进程。
   - 如果找到的是另一个可运行的进程，调度器线程会将其状态从`RUNNABLE`设置为`RUNNING`，并将控制权交给它。

9. **恢复挂起的进程并继续执行**：

   - 当调度器线程再次选择之前被`sleep`挂起的进程时，它通过`swtch`恢复该进程的上下文。
   - 恢复后的进程从被挂起的位置继续执行。这可能是在`syscall`或`usertrap`函数中，具体取决于进程被挂起的原因。
   - 系统调用处理完毕后，`syscall`函数将返回值写入`trapframe`中的`a0`寄存器中。

10. **返回用户态**：

    - `syscall`函数完成后，`usertrap`函数调用`usertrapret`，准备返回到用户态。

    - `usertrapret`会调用`trampoline.S`中的`userret`，恢复用户态寄存器并使用`sret`指令切换回用户态，继续执行用户进程的代码。

### **函数调用链**

- **进入系统调用**：
  1. 用户态：`user code (ecall)`
  2. 内核态：`uservec -> usertrap -> syscall -> sys_sleep -> yield -> sched -> swtch`
- **挂起和上下文切换**：
  1. 调度器线程：`swtch -> scheduler (choose another process) -> swtch`
- **恢复挂起进程**：
  1. 调度器线程：`swtch (restore context)`
  2. 继续执行：`sched -> sys_sleep -> syscall -> usertrapret -> userret -> user code`

---

