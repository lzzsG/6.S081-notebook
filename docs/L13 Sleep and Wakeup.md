---
layout: page
title: L13 Sleep & Wakeup
permalink: /L13
description: "Lecture 13 - Sleep & Wakeup，在本节课中，我们首先回顾了上节课关于线程切换的重要内容，随后会讨论在XV6操作系统中通过`Sleep & Wakeup`实现的协调机制，最后探讨`lost wake-up`问题。"
nav_order: 13




---

# Lecture 13 - Sleep & Wakeup

## 线程切换的回顾与关键点

在本节课中，我们首先回顾了上节课关于线程切换的重要内容，随后会讨论在XV6操作系统中通过`Sleep & Wakeup`实现的协调机制，最后探讨`lost wake-up`问题。

### 1. 线程切换的流程

在XV6中，线程切换是一个关键的过程，通常涉及用户进程的内核线程与调度器线程之间的切换。线程切换的典型流程如下：

1. **获取进程锁**：当一个进程准备进入休眠或需要放弃CPU时，它会首先获取自身的锁。
2. **状态更新**：进程将自己的状态从`RUNNING`设置为`RUNNABLE`，表示它现在可以被调度器再次调度。
3. **调用`swtch`函数**：进程调用`sched`函数，而`sched`函数再调用`swtch`函数，执行线程的切换。
4. **切换至调度器线程**：`swtch`函数完成后，当前线程的上下文切换到调度器线程。
5. **调度器线程恢复执行**：调度器线程在执行时，会从之前调用`swtch`的地方恢复。
6. **释放进程锁**：调度器线程恢复后，释放当前不再运行的进程的锁。

### 2. 获取进程锁的原因

获取进程锁的主要原因是为了避免多核处理器中的调度器线程在进程状态切换期间错误地认为进程是`RUNNABLE`并尝试运行它。具体来说：

- 每个CPU核都有一个调度器线程遍历进程表，当某一核的调度器线程发现某进程状态为`RUNNABLE`时，可能会立即调度该进程。
- 如果未能在进程切换的最初阶段获取进程锁，可能导致在进程尚未完全停止时被另一个核的调度器线程调度，从而使得多个CPU核同时运行同一进程的线程，这将导致系统崩溃。

### 3. 锁的释放时机

- 进程在调用`switch`之前保持其锁不释放，确保在切换过程中调度器线程不会错误地调度该进程。
- 当调度器线程完成切换并确认该进程的线程已停止使用其栈时，才会释放锁。此时，其他CPU核可以安全地调度并运行该进程的线程。

> **提问**：多个CPU核能看到同一个锁对象是否因为它们共享物理内存？

多个CPU核共享同一物理内存系统，因此可以访问相同的锁对象。如果是不同的计算机，它们不共享内存，因此不会出现这类问题。

这个锁机制是保证多核系统中线程安全切换的重要手段，也为后续讨论`Sleep & Wakeup`机制中的限制条件奠定了基础。

接下来，我们将深入探讨`Sleep & Wakeup`机制及其在XV6中的实现，并讨论相关的`lost wake-up`问题。

## 线程切换中的锁管理限制

在XV6操作系统中，线程切换过程中存在一个重要的限制：进程在调用`switch`函数时，必须仅持有`p->lock`（进程对应的`proc`结构体中的锁），且不能持有任何其他的锁。这一规则是避免死锁的关键，也影响了包括`Sleep & Wakeup`机制在内的多个设计。

### 1. 锁管理限制的场景与原因

为了理解这个限制的必要性，我们首先构建一个不满足该限制条件的场景：

- **场景描述**：假设进程P1的内核线程在持有`p->lock`之外的其他锁（例如与磁盘、UART或控制台相关的锁）的情况下，通过调用`switch`函数出让CPU。这时，进程P1持有了一些锁，但进程本身已经停止运行。

- **潜在问题**：在一个单核机器上，当P1调用`switch`后，调度器线程会切换到另一个进程P2。如果P2需要访问磁盘、UART或控制台，并且尝试获取P1持有的锁，P2将无法成功获取该锁。此时，如果锁是自旋锁，那么P2将进入一个忙等待的循环，不停地尝试获取锁。然而，P2无法成功获取锁，导致它无法继续执行，同时它也无法出让CPU，因为自旋锁的获取操作不会返回。这种情况下，P1持有的锁无法释放，导致系统进入死锁状态。

- **多核情况**：虽然上面的描述基于单核系统，但在多核系统中，类似的死锁也可能发生。例如，如果不同的进程分别持有多个锁并尝试在不同核上运行，则可能出现多个CPU核同时进入忙等待的情况，导致全局性的死锁。

### 2. 定时器中断无法解决死锁问题

有学生提问是否可以通过定时器中断将CPU控制切换回P1，从而解决死锁问题。Robert教授对此进行了详细解释：

- **内核上下文中的中断处理**：所有进程切换过程都发生在内核中，所有的锁操作（`acquire`、`switch`、`release`）也是在内核中执行的。虽然在内核中可以触发中断，但在XV6中，`acquire`函数会在等待锁之前关闭中断。这是因为，如果在等待锁时允许中断处理，可能会导致复杂的死锁场景。

- **关闭中断的必要性**：在`acquire`函数中，关闭中断的操作是为了避免在锁定期间发生中断，从而引发死锁。因此，当进程P2在忙等待中尝试获取锁时，中断已经被关闭，定时器中断也无法触发，进而阻止了P2出让CPU控制权回给P1，导致死锁无法被打破。

### 3. 死锁的避免策略

在XV6中，通过以下策略避免上述死锁情况：

- **限制锁的持有**：严格禁止进程在调用`switch`函数时持有除`p->lock`以外的其他锁。这一限制是通过在`sched`函数中添加检查代码来实现的，确保进程在切换时只持有`p->lock`。

这一规则非常重要，因为它确保了在`Sleep & Wakeup`机制中不会因为持有不当的锁而导致死锁。程序员在编写XV6代码时必须遵循这一规则，以确保系统的稳定性和避免潜在的死锁问题。

## 通过Sleep & Wakeup实现线程协调（Coordination）

在编写多线程程序时，线程之间的协调是一个常见的问题。线程往往需要等待特定事件的发生，才能继续执行其后续操作。为了有效地管理这种等待，XV6操作系统提供了`Sleep & Wakeup`机制。这种机制是一种重要的协调工具，类似于锁的作用，它使得线程能够在不浪费CPU资源的情况下等待事件的发生。

### 1. 锁的局限性与线程协调的需求

锁的主要作用是保护共享资源，确保对共享数据的操作是按顺序进行的。然而，锁并不能解决所有的并发问题，特别是在某些场景下，线程需要等待特定事件的发生，例如：

- **等待I/O事件**：例如一个进程等待从Pipe中读取数据，而此时Pipe为空，需要等待数据到达。
- **等待磁盘操作**：一个进程请求读取磁盘上的数据，但由于磁盘读取需要一定时间，进程需要等待读取完成的事件。
- **进程等待子进程退出**：父进程调用`wait`函数等待子进程的退出事件。

这些场景中的等待属于一种“协调”（Coordination）问题，是在锁之外的一种高级并发控制机制。

### 2. Busy-Wait的局限性

最简单的等待事件的方式是`busy-wait`，即通过一个循环不断检查条件是否满足：

- **Busy-Wait**：假设我们在等待一个Pipe的缓冲区中有数据到来，可以通过一个循环不断检查缓冲区是否非空。

  ```c
  while (pipe->buffer_empty) {
      // busy-wait
  }
  ```

`busy-wait`在某些情况下是有效的，例如当等待的事件预计会在极短时间内发生（如0.1微秒以内），特别是在硬件操作中，这种方式可能是最优选择。然而，在等待时间较长的情况下，`busy-wait`显然是不合适的，因为它会浪费大量的CPU时间。

### 3. 通过Sleep & Wakeup实现有效的等待

为了避免`busy-wait`带来的CPU资源浪费，XV6采用了`Sleep & Wakeup`机制：

- **Sleep**：当线程发现需要等待某个事件时，它会调用`sleep`函数进入睡眠状态，释放CPU的使用权。这时，线程不再占用CPU资源，直到等待的事件发生。
- **Wakeup**：当等待的事件发生时，另一个线程（或者是中断处理程序）会调用`wakeup`函数，唤醒之前进入睡眠的线程，使其能够重新获取CPU并继续执行。

这一机制的核心思想是在等待事件发生期间不占用CPU，从而提高系统整体效率。在这种模型下，线程协调得到了有效的实现，避免了`busy-wait`造成的资源浪费。

Sleep & Wakeup`机制为XV6提供了一种高效的线程协调手段，使得线程能够在等待事件时合理地出让CPU资源，直到事件发生时被唤醒继续执行。这种机制广泛应用于操作系统的各个部分，与锁共同构成了操作系统并发控制的基础。

## XV6中的UART驱动实现与Sleep & Wakeup机制

重写的 [UART](https://lzzs.fun/6.S081-notebook/L10#uart%E6%A8%A1%E5%9D%97%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E9%94%81%E7%9A%84%E4%BD%9C%E7%94%A8)（通用异步收发传输器）驱动，使用`Sleep & Wakeup`机制来高效地处理字符的传输。下面我们详细分析`uartwrite`函数和`uartintr`中断处理程序的实现。

### 1. `uartwrite`函数分析

```c
// transmit buf[].
void uartwrite(char buf[], int n)
{
  acquire(&uart_tx_lock);

  int i = 0;
  while(i < n){
    while(tx_done == 0){
      // UART is busy sending a character.
      // wait for it to interrupt.
      sleep(&tx_chan, &uart_tx_lock);
    }
    WriteReg(THR, buf[i]);
    i += 1;
    tx_done = 0;
  }

  release(&uart_tx_lock);
}
```

**功能描述**：

- `uartwrite`函数用于将字符数据写入UART硬件。当系统需要输出字符（例如shell输出），最终会调用到这个函数。
- 由于UART硬件一次只能处理一个字符，且每个字符的传输需要一定时间，因此这个函数通过循环逐个字符地发送。

**流程分析**：

1. **获取锁**：函数开始时调用`acquire(&uart_tx_lock)`获取锁`uart_tx_lock`，确保对UART资源的独占访问。
2. **循环发送字符**：
   - 外层循环遍历需要发送的字符（`buf[i]`）。
   - 内层循环检查`tx_done`标志位，这个标志位表示UART是否准备好接收下一个字符。如果`tx_done`为0，说明UART仍在忙碌，线程进入睡眠状态，等待UART硬件完成当前字符的传输。
   - 当UART硬件准备好时（通过中断处理程序`uartintr`唤醒），线程被唤醒，`tx_done`被设置为1，外层循环继续，将下一个字符写入UART。
3. **释放锁**：所有字符发送完毕后，调用`release(&uart_tx_lock)`释放锁。

**关键点**：

- **睡眠与唤醒机制**：在等待硬件完成字符传输期间，线程不会使用`busy-wait`，而是通过`sleep`函数进入睡眠，释放CPU资源。这种机制避免了CPU的无谓消耗，提高了系统效率。

### 2. `uartintr`中断处理程序分析

```c
// handle a uart interrupt, raised because input has
// arrived, or the uart is ready for more output, or
// both. called from trap.c.
void uartintr(void)
{
  acquire(&uart_tx_lock);
  if(ReadReg(LSR) & LSR_TX_IDLE){
    // UART finished transmitting; wake up any sending thread.
    tx_done = 1;
    wakeup(&tx_chan);
  }
  release(&uart_tx_lock);

  // read and process incoming characters.
  while(1){
    int c = uartgetc();
    if(c == -1)
      break;
    consoleintr(c);
  }
}
```

**功能描述**：

- `uartintr`是UART的中断处理程序，当UART硬件完成一个字符的传输或接收到新输入时，该程序会被`trap.c`调用。

**流程分析**：

1. **处理传输完成事件**：
   - 首先，获取`uart_tx_lock`锁。
   - 读取UART的`LSR`寄存器，检查`LSR_TX_IDLE`标志位以判断是否完成了字符的传输。如果传输完成，设置`tx_done`为1，并调用`wakeup`函数唤醒等待中的线程（即在`uartwrite`函数中睡眠的线程）。
   - 释放锁。

2. **处理接收输入**：
   - 通过循环不断读取UART接收到的字符，调用`consoleintr`函数处理这些输入（如将其显示在控制台）。

**关键点**：

- **中断与线程协调**：中断处理程序`uartintr`在检测到UART完成字符传输时，通过`wakeup`函数通知等待的线程，使其继续执行。这种中断驱动的方式确保了线程只有在必要时才被唤醒，从而提高了系统响应效率。

### 3. Sleep & Wakeup机制的作用

在这个重写的 UART驱动示例中，`Sleep & Wakeup`机制的作用尤为明显：

- **Sleep**：在`uartwrite`中，当线程需要等待某个事件（如UART硬件准备好接收下一个字符）时，它会调用`sleep`进入睡眠状态。这时，线程不占用CPU资源。
- **Wakeup**：当该事件发生时（由UART硬件触发中断），中断处理程序`uartintr`调用`wakeup`函数，唤醒睡眠中的线程，使其继续执行。

这种机制确保了CPU资源的高效利用，避免了`busy-wait`的资源浪费，是XV6实现高效线程协调的关键手段。

## Sleep & Wakeup机制中的Sleep Channel与Lost Wakeup问题

在XV6中，`Sleep & Wakeup`机制通过`sleep channel`实现线程间的精确协调。下面我们将深入探讨`sleep channel`的作用、接口设计的灵活性以及为什么需要传入锁作为`sleep`函数的参数。

### 1. Sleep Channel的作用

- **Sleep Channel的定义**：`sleep`和`wakeup`函数都接受一个称为`sleep channel`的参数，这是一个64位数值，用来标识线程等待或被唤醒的特定事件。这个参数的作用是将调用`sleep`函数的线程与调用`wakeup`函数的线程关联起来，使得`wakeup`只会唤醒那些正在等待特定事件的线程。

- **工作原理**：

  1. 当一个线程调用`sleep(chan, lock)`时，它进入睡眠状态并与指定的`sleep channel`关联。
  2. 另一个线程调用`wakeup(chan)`时，`wakeup`函数会检查是否有线程在等待相同的`sleep channel`，如果有，就唤醒这些线程。

  通过这种方式，`sleep`和`wakeup`函数实现了线程间的精确协调。

### 2. Sleep & Wakeup接口的灵活性

- **接口的简单性和通用性**：`sleep`和`wakeup`函数只接受一个简单的64位数值作为`sleep channel`，不关心这个数值代表什么。这种设计使得接口非常灵活，可以用于各种不同的同步场景，而不需要对具体的事件类型有任何预先定义。

- **灵活性带来的挑战**：尽管这种灵活性非常强大，但它也引入了一些复杂性和潜在的问题，尤其是在处理`lost wakeup`问题时。`lost wakeup`是指当某个事件已经发生，但相关的线程还没有进入睡眠状态，这时如果触发了`wakeup`，可能导致该线程永远无法被唤醒。

### 3. 为什么需要传入锁？

- **锁的作用**：在`sleep(chan, lock)`函数中，传入的锁用于在线程进入睡眠前确保对共享资源的正确访问。

- **避免`lost wakeup`**：
  - 如果没有传入锁，可能会导致一个竞争条件，即一个线程在决定进入睡眠后但尚未实际进入睡眠时，另一个线程已经触发了`wakeup`。这将导致`wakeup`调用没有效果，从而引发`lost wakeup`问题。
  - 通过在`sleep`函数中传入锁，保证在进入睡眠和触发唤醒之间没有空隙，避免了这种竞争条件。这个机制确保了`wakeup`在适当的时候唤醒正确的线程。

- **设计的权衡**：虽然传入锁使接口略显复杂和“丑陋”，但这是为了在实际操作系统中避免死锁和`lost wakeup`问题的必要措施。由于线程在等待事件时，往往还需要保护对共享资源的访问，因此引入锁的设计也符合并发编程中的实际需求。

> **提问:** UART驱动程序中是否每传输一个字符就会唤醒一次。

在这个简化的UART驱动程序中，传输每个字符都会触发一次中断，从而唤醒等待中的线程。对于每个字符的传输，都会经历`sleep`、`wakeup`的循环过程。

实际的UART硬件通常支持一次传输多个字符（如4或16个字符），因此可以优化驱动程序，让每次循环传输多个字符，并在一次中断时唤醒线程。这种优化能减少中断和`sleep/wakeup`调用的频率，提高系统效率。

## Lost Wakeup问题与缺乏锁的Sleep函数问题

在讨论`sleep`函数为何需要传入锁作为参数之前，我们可以设想一个更简单的、不带锁参数的`sleep`函数。这种设计虽然看似简化了接口，但实际上会引发严重的问题，尤其是**lost wakeup**问题。为了说明这一点，我们假设一个仅接收`sleep channel`作为参数的简化版`sleep`函数，称之为`broken_sleep`。

### 1. `broken_sleep`的实现及问题

**`broken_sleep`的设想**：

- `broken_sleep`函数设想中，仅接收一个`sleep channel`参数。它的操作步骤如下：
  1. 将当前进程的状态设置为`SLEEPING`，表示进程进入睡眠，等待特定的事件。
  2. 记录该进程对应的`sleep channel`，以便之后的`wakeup`函数能够找到并唤醒这个进程。
  3. 调用`switch`函数，出让CPU的控制权，使得其他进程可以运行。

**`wakeup`函数的设想**：

- `wakeup`函数遍历系统中所有进程的进程表，寻找状态为`SLEEPING`且`sleep channel`匹配的进程，然后将这些进程的状态设置为`RUNNABLE`，使它们可以被调度执行。

**潜在问题：Lost Wakeup**：

- **Lost Wakeup的定义**：Lost wakeup是指当事件已经发生，但由于某种竞争条件或时序问题，相关的线程并没有被正确唤醒，导致该线程无法继续执行。例如，`wakeup`函数在`broken_sleep`设置进程状态之前就运行，导致`wakeup`无法正确识别并唤醒等待的进程。
- **问题产生的原因**：由于`broken_sleep`没有锁保护，在`sleep`设置进程为`SLEEPING`状态并记录`sleep channel`期间，可能已经有另一个线程或中断触发了`wakeup`，但此时该进程尚未完全进入睡眠状态，结果导致`wakeup`未能正确唤醒进程，最终该进程会无限期地等待，形成死锁或未响应的状态。

### 2. `UART`驱动中的`broken_sleep`问题示例

**UART驱动使用`broken_sleep`的场景**：

- 在使用`broken_sleep`的场景中，我们定义了一个`done`标志位，用于表示UART硬件是否完成了字符传输。`uartwrite`函数会检查这个标志位，如果`done`为0，则调用`sleep`函数进入睡眠，等待UART硬件准备好接收下一个字符。中断处理函数`uartintr`在传输完成后会设置`done`为1，并调用`wakeup`函数唤醒等待的进程。

**缺乏锁的问题**：

- **共享数据的竞争访问**：`done`标志位是共享数据，因此必须通过锁保护，以防止`uartwrite`和`uartintr`函数同时访问和修改`done`，导致数据不一致。
- **硬件资源的竞争访问**：`uartwrite`和`uartintr`函数同时访问UART硬件的寄存器，这种并发访问没有锁的保护，可能导致不可预知的行为，例如数据损坏或硬件操作失败。

**没有锁的设计下可能的执行顺序**：

1. `uartwrite`线程准备调用`sleep`，将进程状态设置为`SLEEPING`。
2. 在`sleep`函数尚未记录`sleep channel`之前，`uartintr`中断发生，设置`done`为1，并调用`wakeup`。
3. `wakeup`函数由于找不到对应的睡眠线程，因此什么都不做。
4. `uartwrite`线程继续执行，调用`sleep`，但此时中断已经触发过，`wakeup`已经被错过，导致`uartwrite`线程永久进入睡眠。

### 3. 为什么需要锁保护

**锁的作用**：

- **确保操作的原子性**：锁的主要作用是确保`sleep`函数内的操作是原子性的，即在整个`sleep`过程中不会发生中断或其他线程的干扰。这样可以避免在`sleep`进入睡眠状态和`wakeup`唤醒操作之间发生时序问题，确保正确的线程能够被唤醒。
- **保护共享资源**：在多线程环境中，所有共享资源（如`done`标志位和UART硬件寄存器）都应受到锁的保护，以防止数据竞争和不一致。

**解决方案**：

- 在`sleep(chan, lock)`函数中传入锁，确保在`sleep`设置进程状态并记录`sleep channel`时，不会有其他线程或中断干扰这一过程。这可以避免`lost wakeup`问题，同时确保`wakeup`函数在正确的时机唤醒对应的线程。



## 锁的使用位置与`broken_sleep`函数的问题

在实现多线程协调时，正确管理锁的使用位置是至关重要的。为了说明问题，我们假设了一个不带锁参数的`sleep`函数，即`broken_sleep`。下面继续分析在UART驱动中使用`broken_sleep`时可能会发生的问题，以及正确的锁使用方式。

### 1. 锁在`uartintr`中的使用

在`uartintr`中断处理程序中，锁的使用较为简单。通常，我们会在进入中断处理程序的最开始获取锁，执行完操作后在退出时释放锁。这是为了确保中断处理程序访问共享资源时不与其他线程发生冲突。

### 2. 锁在`uartwrite`中的使用

在`uartwrite`函数中，锁的使用稍显复杂。我们希望在处理共享资源时保护它们，但在等待`done`标志位时，我们需要释放锁以允许中断处理程序执行，否则会引发死锁。

### 错误的锁使用方式

一种看似合理但实际上有问题的方式是对整个字符发送过程加锁。如下所示：

```c
acquire(&uart_tx_lock);

int i = 0;
while(i < n){
    while(tx_done == 0){
        // 锁保护整个等待过程
        sleep(&tx_chan, &uart_tx_lock);
    }
    WriteReg(THR, buf[i]);
    i += 1;
    tx_done = 0;
}

release(&uart_tx_lock);
```

**为什么这样会出问题？**

- `uartwrite`函数持有锁进入`sleep`等待`tx_done`标志位变化，中断处理程序无法获取锁来更新`tx_done`，这导致中断处理程序无法唤醒正在等待的线程。
- 结果是`uartwrite`线程永远无法被唤醒，导致系统进入死锁状态。

### 正确的锁使用方式

为了避免死锁，我们需要在`sleep`之前释放锁，并在`sleep`返回后重新获取锁。如下所示：

```c
acquire(&uart_tx_lock);

int i = 0;
while(i < n){
    while(tx_done == 0){
        release(&uart_tx_lock);      // 在sleep之前释放锁
        sleep(&tx_chan, &uart_tx_lock); // sleep函数负责重新获取锁
        acquire(&uart_tx_lock);      // 重新获取锁
    }
    WriteReg(THR, buf[i]);
    i += 1;
    tx_done = 0;
}

release(&uart_tx_lock);
```

**为什么这样可行？**

- 当`sleep`被调用时，锁已经被释放，因此中断处理程序可以正常执行，并更新`tx_done`标志位。更新后，中断处理程序调用`wakeup`唤醒`uartwrite`，此时`sleep`返回并重新获取锁，`uartwrite`可以继续执行。

### 3. `broken_sleep`的使用及其问题

假设我们用`broken_sleep`代替`sleep`，并手动管理锁的获取和释放：

```c
void uartwrite(char buf[], int n)
{
  acquire(&uart_tx_lock);

  int i = 0;
  while(i < n){
    while(tx_done == 0){
      release(&uart_tx_lock);
      broken_sleep(&tx_chan);  // 调用不带锁的broken_sleep
      acquire(&uart_tx_lock);
    }
    WriteReg(THR, buf[i]);
    i += 1;
    tx_done = 0;
  }

  release(&uart_tx_lock);
}
```

**`broken_sleep`的实现：**

```c
void broken_sleep(void* chan)
{
  p->state = SLEEPING; // 设置进程状态
  p->chan = chan; // 记录`chan`
  swtch(); // 切换进程
}
```

**问题分析：**

- 在`broken_sleep`执行期间，锁已经被释放。但由于`broken_sleep`没有保护关键的`sleep`过程（例如设置进程状态、记录`chan`等操作），在`sleep`的关键时刻可能会发生竞争条件。
- 如果中断在`broken_sleep`将进程状态设置为`SLEEPING`前发生，`wakeup`将无法找到匹配的进程进行唤醒，导致`lost wakeup`问题，进程将永远处于等待状态。

## Lost Wakeup问题的实际运行结果与分析

在编译和运行修改后的代码时，我们遇到了`lost wakeup`问题。让我们来分析导致该问题的代码段，并理解它在实际运行中的表现。

### 1. 代码运行现象

在XV6启动时，系统会打印“init starting”，但在修改后的代码中，输出一些字符后系统挂起。如果在此时手动输入任意字符，剩余的字符才会被继续输出。

### 2. 代码中导致问题的关键部分

以下是代码中可能引发问题的部分：

```c
release(&uart_tx_lock);
// 这里可能会发生中断
broken_sleep(&tx_chan);
acquire(&uart_tx_lock);
```

### 3. 问题产生的原因：Lost Wakeup

**中断的时机**：

- 当`uartwrite`函数在释放锁（`release(&uart_tx_lock)`）和进入`broken_sleep`之间，中断可能会发生。这是因为释放锁后，中断被重新打开，其他CPU核有可能执行UART的中断处理程序。

**中断处理程序行为**：

- 其他CPU核可能在这个时间点获取了锁，发现UART硬件已经完成了字符传输，并设置`tx_done`为1。
- 接着，中断处理程序调用`wakeup(&tx_chan)`，但此时`uartwrite`线程还没有进入`SLEEPING`状态。因此，`wakeup`没有唤醒任何进程，因为还没有任何线程在`tx_chan`上睡眠。

**结果**：

- 当`uartwrite`线程继续执行，调用`broken_sleep(&tx_chan)`时，它将状态设置为`SLEEPING`，但此时中断已经发生且`wakeup`也已经被调用。这导致`uartwrite`线程进入了睡眠状态，等待一个已经错过的事件。这就是典型的`lost wakeup`问题。

> **提问**：是不是一旦`wakeup`丢失，下一次`wakeup`时，之前的数据就会继续输出？

这完全依赖于具体实现。在这个例子中，由于输入和输出都共用同一个中断处理程序，因此在输入字符时，偶然地触发了`wakeup`，解决了`lost wakeup`问题，导致数据继续输出。然而，这种行为是偶然的，并不可靠。如果UART使用了不同的中断处理程序来分别处理接收和发送事件，那么这种问题就无法通过后续的输入操作来修复，系统可能会继续挂起。

### 4. 总结与解决办法

- **Lost Wakeup问题**：在多核系统中，如果`wakeup`在线程进入睡眠状态之前被触发，就可能导致`lost wakeup`问题，使得等待的线程永远不会被唤醒，系统可能会挂起。
- **解决办法**：要避免这种情况，应该使用带锁参数的`sleep`函数。通过在`sleep`函数内部管理锁的获取和释放，可以确保`wakeup`函数在正确的时机唤醒正确的线程，避免`lost wakeup`问题。

## 关于`tx_done`标志位和Lost Wakeup问题的深入讨论

### 1. `tx_done`标志位的作用

- **通信的桥梁**：`tx_done`标志位是`uartintr`（中断处理程序）和`uartwrite`函数之间的一种简单通信手段。它用于指示UART硬件是否已经完成了当前字符的传输。
- **传输状态指示**：当`tx_done`为1时，表示UART已经完成了前一个字符的传输，`uartwrite`函数可以安全地传输下一个字符。这种标志位机制允许`uartwrite`函数和`uartintr`之间通过共享状态来协调操作。

### 2. `tx_done`标志位是否多余？

既然`sleep`函数唤醒时已经知道是来自UART的中断处理程序调用`wakeup`，为什么还需要`tx_done`标志位？

- **睡眠与唤醒的非精确匹配**：`tx_done`标志位并非多余，它解决了一个更为普遍的问题：在多线程环境中，`sleep`函数和`wakeup`函数通常不能精确匹配。也就是说，当`sleep`函数返回时，等待的事件可能已经被另一个线程处理了。
- **避免竞态条件**：考虑到多线程并发的可能性，可能有多个线程在尝试写入UART。一个线程进入`sleep`状态后，另一个线程可能已经处理了相应的事件，导致第一个线程被唤醒时，事件已经发生，但该线程并不具备继续操作的条件。因此，使用`while(tx_done == 0)`循环来再次检查状态是确保线程正确协调的一种方式。
- **普遍的解决方案**：这种模式不仅适用于UART传输，还广泛应用于操作系统中的其他场景。实际上，XV6中的大多数`sleep`函数调用都会被一个`while`循环包围，以确保唤醒的线程在实际处理事件之前重新检查条件。

### 3. 为什么没有更多的`lost wakeup`？

在输入字符后系统继续输出剩余字符时，为什么没有再次发生`lost wakeup`？

- **`lost wakeup`的偶发性**：`lost wakeup`问题是由于中断处理程序和`sleep`函数之间的竞争条件引发的。这种情况需要特定的时序条件：中断在锁释放和`sleep`之间发生。这种情况虽然有可能发生，但并不总是出现。
- **演示`lost wakeup`的条件**：在实际操作中，例如执行`cat README`，由于大量字符输出，`lost wakeup`更容易发生。当系统输出数千个字符时，你会注意到每隔一段时间系统就会挂起，要求再次输入字符来继续。这是因为在长时间运行期间，系统更可能遇到多个`lost wakeup`事件。
- **巧合与概率**：在之前的演示中，之所以没有频繁出现`lost wakeup`，是因为需要多个条件巧合同时发生。这解释了为什么在某些情况下，`lost wakeup`问题表现得不那么明显。
