---
layout: page
title: L05 RISC-V Calling Convention and Stack Frames
permalink: /L05
description: "在今天的课程中，我们将深入探讨C语言如何转换为汇编语言，并进一步理解汇编语言如何与处理器交互，尤其是在RISC-V架构下的实现。尽管这一过程对页表管理并非至关重要，但它对理解trap机制、trapframe以及栈操作至关重要，尤其是在即将进行的traps lab实验中，这些内容会频繁涉及。"
nav_order: 5




---

# Lecture 5 - RISC-V Calling Convention and Stack Frames

### RISC-V 调用约定和堆栈帧

## RISC-V处理器、汇编语言与C语言转换过程详解

在今天的课程中，我们将深入探讨C语言如何转换为汇编语言，并进一步理解汇编语言如何与处理器交互，尤其是在RISC-V架构下的实现。尽管这一过程对页表管理并非至关重要，但它对理解trap机制、trapframe以及栈操作至关重要，尤其是在即将进行的traps lab实验中，这些内容会频繁涉及。

### C语言到汇编语言的转换流程简述

通常，我们编写的C语言程序包含一个`main`函数，该函数负责执行程序的主要逻辑。C语言编程简洁明了，具有结构化的控制流程，例如循环、条件语句和函数调用。然而，处理器并不能直接理解C语言代码。为了让处理器执行我们的程序，必须将C语言代码转换为汇编语言。

1. **C语言的编译过程**：
   - **编写C语言代码**：程序员编写的C语言代码通常包含各种逻辑操作、函数调用以及数据处理指令。编写C代码时，开发者关注的是高级逻辑结构、数据管理和算法实现，而不必过多关心底层硬件的具体操作细节。
   - **编译为汇编语言**：C语言代码经过编译器的处理，被转换为汇编语言。汇编语言是一个更接近处理器底层的指令集，可以被处理器理解和执行。编译器在这一过程中还会进行优化，调整代码的结构以提高执行效率。例如，某些高层次的循环结构可能会被优化为更简洁的汇编指令序列。
   - **汇编语言到机器码的转换**：汇编语言进一步被转换为机器码（二进制文件），这些机器码包含了处理器能够理解的指令集。这一步通过汇编器完成，汇编器将每一条汇编指令翻译为对应的机器码，并生成可执行的二进制文件。

   在这个过程中，编译器负责将高级语言（如C语言）编译成处理器能够理解的低级指令（汇编语言），然后链接器将这些指令打包成二进制可执行文件。链接器还负责将不同的代码模块和库函数整合到一起，形成完整的可执行程序。

2. **汇编语言的特点**：
   - 汇编语言由一系列指令组成，如`add`、`sub`、`mult`等。这些指令直接对应处理器的操作。每一条汇编指令都对处理器的一个具体操作进行了抽象，允许开发者直接控制硬件。
   - 每一条汇编指令都有一个对应的二进制编码，称为操作码（Opcode），处理器根据操作码来执行相应的操作。操作码是处理器硬件直接理解的语言，通过这些二进制编码，处理器能够识别并执行指令。
   - 汇编语言没有高级语言中的控制结构（如循环、条件语句），这些结构在汇编语言中是通过标签（label）和跳转指令（如`jmp`）来实现的。例如，`for`循环在汇编语言中可能被翻译为一组比较和跳转指令，通过不断调整程序计数器来实现循环的效果。
   - 汇编语言非常底层，没有函数定义的概念，函数在汇编语言中是通过标签来实现的。函数调用与返回通常通过跳转指令（如`call`和`ret`）以及栈操作来实现，调用约定决定了函数参数如何传递、返回值如何处理以及栈帧如何管理。

### RISC-V处理器与指令集架构（ISA）

RISC-V处理器是当前广泛使用的开源处理器架构之一。它的指令集架构（ISA）定义了处理器可以理解和执行的指令。

1. **RISC-V指令集**：
   - RISC-V是一种精简指令集计算（RISC）架构，设计简单，扩展性强。其指令集结构遵循简洁性原则，每条指令执行一个非常简单的操作，这使得指令的执行速度更快，处理器设计也更为简单。
   - 每条RISC-V指令都对应一个操作码，RISC-V处理器根据这些操作码来执行基本的运算、数据传输和控制流操作。RISC-V的指令集非常模块化，不同的扩展模块（如浮点操作、向量操作）可以根据需求自由组合。

2. **汇编语言与RISC-V的关系**：
   - 编译后的汇编语言与RISC-V指令集直接对应。这意味着每一条汇编语言指令都可以直接映射到RISC-V处理器的操作码。这种直接的映射关系有助于理解程序的执行流程，以及如何优化代码以适应特定的硬件架构。
   - RISC-V的汇编语言具有良好的可读性和可理解性，使其成为学习处理器工作原理的理想选择。RISC-V简洁的指令集和开放的标准使得其汇编语言在教育和研究领域得到了广泛应用。

### 处理器与汇编语言的执行流程

1. **汇编语言到机器码**：
   - 汇编语言经过汇编器的处理，被转换为机器码（.obj或.o文件）。这些文件包含了处理器能够理解的二进制指令。这一步是将抽象的汇编指令变为具体的机器码，准备就绪后，处理器便能直接执行这些指令。
   - 汇编器除了简单的指令翻译外，还会进行一些低级别的优化，例如指令重排以提高指令流水线的效率。

2. **机器码的执行**：
   - 处理器从内存中读取这些二进制指令，然后依次执行。处理器内的控制单元解析操作码，并调用相应的硬件资源（如算术逻辑单元、寄存器等）来完成指令操作。处理器执行指令的过程是完全机械化的，按照操作码一步一步地完成指令中规定的操作。
   - 每执行一条指令，处理器都会根据其类型进行相应的操作，例如算术运算、数据传输或跳转控制，最终实现程序逻辑的执行。

3. **与主板的交互**：
   - 处理器通过主板上的总线与其他硬件组件（如内存、I/O设备）进行交互。每一个硬件组件都有一个独立的物理地址，处理器通过这些地址来访问硬件资源。RISC-V处理器通过内存映射I/O（MMIO）方式与外设进行通信，处理器通过读写特定地址实现对外设的控制。

### C语言编译与RISC-V架构的具体示例

在实际应用中，我们通常会在实验环境（如QEMU模拟器）中编译并执行C语言代码。在这之前，我们可以在实验目录中找到许多.o文件和.asm文件，这些文件正是经过上述编译流程产生的。

1. **示例**：
   - 当你编写并编译一个简单的C程序（例如，打印一段文本后退出），C编译器会将其转换为RISC-V汇编语言，并最终生成对应的.o文件。这些.o文件包含处理器能够理解的二进制指令。通过检查生成的.o文件，可以了解编译器如何将高级语言代码映射到具体的硬件指令上。
   - 这些.o文件不仅包括了程序的主要逻辑，还可能包含一些初始化代码和运行时支持库，这些部分对于程序的正常执行至关重要。

2. **观察汇编代码**：
   - 如果你查看生成的.asm文件，可以看到C语言代码被翻译成了一行行的RISC-V汇编指令。这些指令执行的是与C代码相同的逻辑，只不过是在处理器理解的层面上。通过分析这些汇编指令，可以更好地理解程序的执行过程，甚至可以手动进行一些优化。

理解C语言到汇编语言的转换过程，以及汇编语言在RISC-V处理器上的执行流程，是深入理解操作系统如何与底层硬件交互的基础。在即将进行的traps lab实验中，这些知识将帮助你们更好地理解trap机制和栈的工作原理。通过掌握这些基础知识，你们将能够更自如地处理与处理器和汇编语言相关的低级操作，为深入学习操作系统的核心概念打下坚实的基础。

## RISC-V汇编与其他指令集架构的比较与应用

在这节课中，我们反复提到了RISC-V汇编语言，这是因为汇编语言本身是与处理器架构紧密相关的，而不同的处理器架构具有不同的汇编语言。例如，RISC-V和x86-64这两种架构就有各自不同的汇编语言。理解这些差异不仅有助于掌握RISC-V，还能帮助你更好地理解其他常见的处理器架构。

### RISC-V与x86的基本对比

1. **汇编语言的多样性**：
   - 汇编语言的种类多样，主要因为不同的处理器架构有不同的指令集。RISC-V是一个相对较新的架构，它的汇编语言与更为传统的x86-64汇编语言在许多方面存在差异。
   - 你的个人电脑上通常运行的处理器是基于x86架构的，例如Intel或AMD的CPU。而RISC-V是一个开源的指令集架构，正在逐渐被更多的硬件制造商采用。

2. **RISC与CISC的区别**：
   - **RISC（精简指令集计算，Reduced Instruction Set Computer）**：RISC-V属于这一类架构。RISC架构的设计原则是指令简单、数量少，每条指令执行一个基本操作，从而优化执行效率并减少处理器设计的复杂性。
   - **CISC（复杂指令集计算，Complex Instruction Set Computer）**：x86架构属于这一类。CISC架构的指令集复杂，指令数量多，每条指令可以执行多个操作，这使得编程更为灵活，但也增加了处理器的设计和制造难度。

3. **指令集的数量与复杂性**：
   - RISC-V的指令集非常精简，这使得它的学习曲线相对较低。RISC-V的指令集由两份文档详细说明，总共约375页。
   - 相比之下，x86-64的指令集非常庞大，有数万条指令，并且其文档复杂且难以全部掌握。x86-64的指令集文档是逐年扩展的，这反映了它的长期演进和广泛应用。

4. **开放性与应用场景**：
   - RISC-V的开源特性使得它可以被任何组织或个人自由使用和开发。这种开放性是RISC-V的重要优势之一，吸引了很多科技公司的支持和参与。
   - RISC-V主要应用于嵌入式系统、研究项目和某些新兴领域，而x86-64则广泛应用于桌面电脑、服务器和大多数的商用计算设备。

### RISC-V与其他精简指令集的应用

1. **ARM与移动设备**：
   - ARM是另一种非常成功的精简指令集架构。它广泛应用于移动设备，比如Android手机中通常使用的高通Snapdragon处理器就是基于ARM架构的。
   - 苹果的iOS设备（包括iPhone和iPad）也使用基于ARM的处理器。最近，苹果公司在其Mac系列产品中也开始采用基于ARM的自研处理器。

2. **RISC-V的实际应用**：
   - RISC-V已经在一些嵌入式设备中得到了应用。例如，某些微控制器和物联网（IoT）设备已经开始使用RISC-V处理器。
   - 虽然RISC-V目前在桌面和服务器市场的占有率还很低，但随着技术的发展和更多公司对其支持，RISC-V在这些领域的应用潜力巨大。

### RISC-V的未来发展与学习价值

1. **RISC-V在教育与研究中的应用**：
   - RISC-V由于其简单性和开放性，成为了很多计算机科学教育和研究中的首选架构。这使得学生和研究人员可以深入理解计算机系统的底层工作原理。
   - 在课程和实验中，使用RISC-V可以帮助学生更好地掌握汇编语言和处理器架构设计的核心概念。

2. **RISC-V的扩展与前景**：
   - 随着RISC-V在各种领域的应用扩展，我们可能会看到更多基于RISC-V的硬件和软件生态系统。这包括操作系统、编译器、工具链以及应用程序的广泛支持。
   - 作为一个开源指令集，RISC-V的未来充满了创新的可能性，这对于开发者、硬件制造商和最终用户来说都是一个巨大的优势。

## RISC-V的兴起与x86的持久性

在近几年，随着对精简指令集（RISC）的重视增加，RISC-V的使用变得越来越广泛。这种趋势部分原因在于传统复杂指令集（CISC），特别是Intel的x86架构，随着时间的推移指令集规模变得过于庞大且复杂。Intel处理器的指令集之所以如此庞大，主要是由于其强烈的向后兼容性需求。即使是现代的Intel处理器仍然能够执行30到40年前的指令，这是因为Intel几乎从未淘汰过任何一条指令。

### 向后兼容性与指令集规模

>  **提问：为什么x86会有15000条指令？**  

这主要是为了保证向后兼容性的重要性，以及满足特定应用的需求。x86指令集的庞大部分是由于历史遗留问题。Intel希望确保其处理器能够支持早期的所有软件，这就要求它的指令集不能抛弃旧的指令。此外，x86指令集还包括了很多专用的命令指令（cmd），这些指令通常是为特定任务设计的。虽然x86拥有如此多的指令，但大多数程序员实际上只会使用其中的一小部分，大部分指令仅仅是为了特定用途或者兼容性存在的。

### RISC-V的模块化设计

RISC-V与x86的一个显著不同之处在于它的模块化设计。RISC-V指令集分为基础整数指令集（Base Integer Instruction Set）和标准扩展指令集（Standard Extension Instruction Set）。

- **Base Integer Instruction Set**：包含所有基本且常用的指令，例如加法（add）和乘法（mult）等。这些是每个RISC-V处理器都必须支持的基础指令。
- **Standard Extension Instruction Set**：允许处理器制造商根据需要选择性地支持一些扩展指令集。例如，处理器可以选择支持单精度浮点运算（Single-Precision Floating-Point）。这种设计使得RISC-V处理器既能保持精简，又能通过扩展满足不同应用的需求。

这种模块化的指令集设计还意味着RISC-V处理器可以更容易地保持向后兼容性。每个RISC-V处理器可以声明它支持哪些扩展指令集，然后编译器就可以根据这些声明生成与之兼容的代码。这为RISC-V带来了灵活性，同时也避免了像x86那样由于历史包袱而产生的复杂性。

### x86的持久性与RISC-V的挑战

> **提问：为什么我们仍然使用x86，而不是转向RISC-V？**  

这是一个复杂的问题，虽然RISC-V有其优势，但x86的持久性主要来自于其在市场中的主导地位和广泛的软件生态系统。全世界大部分的计算机和软件都是为x86架构设计的，如果突然全部转向RISC-V，将会面临巨大的兼容性问题和转换成本。此外，Intel通过持续创新，例如在处理器中引入安全相关的“Enclave”技术，使得x86在特定领域的性能依然无可匹敌。x86中一些非常具体的指令设计得极为高效，能在某些特定任务中胜过RISC-V。

RISC-V虽然灵活、精简且易于扩展，但它在个人计算机市场的应用还处于起步阶段。目前，支持RISC-V的硬件还比较稀缺，尤其是在桌面计算领域。尽管如此，随着像SiFive这样的公司开始推出基于RISC-V的个人计算机，我们可能会看到更多的创新和应用。然而，在短期内，由于无法在RISC-V上运行大量现有的x86软件，x86架构仍然会在市场中占据主导地位。

综上所述，RISC-V的精简性、开放性和广泛应用场景使其成为一个值得深入学习和探索的领域。随着课程的推进，我们将更深入地了解RISC-V架构下的具体实现，包括在trap、栈操作和处理器交互等方面的应用。这将为我们在操作系统和硬件设计领域奠定坚实的基础。

RISC-V的兴起体现了精简指令集架构的优势，尤其是在保持指令集简单、灵活和开放方面。相比之下，x86的庞大复杂性虽然在某些方面带来了更高的性能，但也使其难以在现代计算环境中保持同样的灵活性。然而，由于x86在市场中的主导地位和深厚的软件生态系统支持，它依然是大多数计算平台的首选架构。未来，随着RISC-V的逐步推广和硬件生态的完善，我们可能会看到这两种架构在更多领域的共存和竞争。

## C语言与汇编语言的转换过程详述

在C语言编程中，我们通常会编写一个`main`函数，完成一系列操作，比如打印数据，然后退出。这在代码层面上看起来非常直观且易于理解。然而，如同你们在6.004课程中学到的，处理器实际上并不能直接理解和执行C语言代码。处理器只能够理解汇编语言的二进制码。

### 处理器与指令集架构（ISA）

当我们提到某个处理器是RISC-V处理器时，这意味着它能够理解和执行RISC-V指令集。每种处理器都有与之相关联的指令集架构（ISA，Instruction Set Architecture），该架构定义了处理器所能够执行的指令集。这些指令以特定的二进制编码或操作码（Opcode）表示。当处理器在运行时遇到这些特定格式的二进制码时，它就会按照指令集架构规定的操作来执行相应的指令。在这个例子中，我们的主板上的处理器能够理解由C语言编译出来的RISC-V汇编语言。

### C语言代码到汇编语言的转换

为了让C语言代码能够在处理器上运行，代码需要经历一系列转换步骤。首先，编写的C代码会被**编译器**编译成汇编代码。在这个编译过程中，编译器会对C语言的高级结构进行解析，并将其转换为RISC-V汇编语言的指令。这些指令通常是非常基础的操作，比如将数据从一个寄存器移动到另一个寄存器、执行算术运算、或控制程序的执行流程。

在编译过程中，**链接器**还会负责将多个模块的代码和库函数结合在一起，以形成一个完整的可执行程序。链接器不仅将C代码生成的汇编指令进行整合，还负责解析外部符号（如函数和变量），确保它们在程序中正确链接。链接后的汇编代码会被进一步转换成机器码，这些机器码是处理器能够直接理解的二进制文件（通常是.o文件）。

如果你曾经在执行完`make qemu`命令后留意过实验文件夹中的内容，你会发现生成了许多.o文件，这些就是处理器可以直接理解的二进制文件。此外，你可能已经注意到实验中还生成了某些.asm文件，这些文件也是由C代码编译生成的汇编代码。

例如，你们可能记得有一个`usys.pl`文件被编译成了一个`usys.s`文件，而这个.s文件就是包含RISC-V汇编代码的文件。这个汇编文件中的每一行指令都直接对应着处理器的操作，它们共同构成了程序的执行逻辑。实际上，你们已经见过RISC-V汇编代码。如果你们上过6.004课程，那么你们一定已经熟悉了大量的汇编代码。

> > ### C语言代码到汇编语言的转换
> >
> > 为了更好地理解C语言代码如何转换为汇编语言并最终运行在处理器上，我们可以将整个流程分解为几个关键步骤。下图将通过符号框图展示C代码到机器码的转换过程，同时解释各个中间文件的含义和作用。
> >
> > ```
> > +--------------------------------+
> > |     C Source Code (.c files)   |
> > |                                |
> > |  -> 编写的C代码：包含高级结构和逻辑 |
> > +--------------------------------+
> >                 |
> >                 v
> > +------------------------------+
> > |     Preprocessing (.i files) |
> > |                              |
> > |  -> 预处理：处理头文件、宏定义等  |
> > +------------------------------+
> >                 |
> >                 v
> > +-------------------------------+
> > |       Compilation (.s files   |
> > |                               |
> > |  -> 编译：将C代码转换为汇编代码   |
> > |  -> 汇编文件：包含处理器的汇编指令 |
> > +-------------------------------+
> >                 |
> >                 v
> > +-----------------------------------+
> > |       Assembly (.o files)         |
> > |                                   |
> > |  -> 汇编：将汇编代码转换为机器码       |
> > |  -> 目标文件：处理器可以理解的二进制代码|
> > +-----------------------------------+
> >                 |
> >                 v
> > +----------------------------------+
> > |       Linking (Executable)       |
> > |                                  |
> > |  -> 链接：整合多个.o文件和库函数      |
> > |  -> 可执行文件：包含完整程序的机器码   |
> > +-----------------------------------+
> > ```
> >
> > ### 各种类型的中间文件的含义和作用
> >
> > 1. **C Source Code (.c files)**: 
> >    - **作用**: 包含了程序的核心逻辑，使用高级结构和语法编写。
> >    - **过程**: 这是程序的起点，通过编译器被处理并转换为汇编代码。
> >
> > 2. **Preprocessing (.i files)**:
> >    - **作用**: 包含预处理后的C代码，处理了所有的宏定义、头文件的引入以及条件编译。
> >    - **过程**: 编译器首先对C代码进行预处理，生成预处理后的文件，这个文件用于下一步的编译。
> >
> > 3. **Compilation (.s files)**:
> >    - **作用**: 汇编文件，包含了由编译器生成的汇编代码。
> >    - **过程**: 编译器将C语言代码转换为汇编语言。汇编语言是低级的、与处理器架构密切相关的代码。
> >
> > 4. **Assembly (.o files)**:
> >    - **作用**: 目标文件，包含处理器能够直接理解的机器码。
> >    - **过程**: 汇编器将汇编代码转换为机器码，生成.o文件。每个.o文件对应一个C文件中的代码部分。
> >
> > 5. **Linking (Executable)**:
> >    - **作用**: 可执行文件，包含完整的程序代码，已经整合了所有模块和库函数。
> >    - **过程**: 链接器将多个.o文件和必要的库文件链接成一个整体，生成最终的可执行程序。

### 汇编语言的低级别特性

汇编语言与C语言相比，其结构化程度要低得多。在C语言中，代码通常具有较为直观的结构，比如函数、循环、条件语句等。然而，在汇编语言中，代码则是一行行的指令，执行的操作更为基础。每一条汇编指令通常只能执行一个非常简单的操作，例如加法、减法、或将数据从一个寄存器移动到另一个寄存器。汇编语言中没有高级语言中的复杂控制结构，如for循环或if条件语句，而是通过标签和跳转指令（如`jmp`）来实现这些控制流。

例如，汇编语言中你会看到诸如`add`、`mul`等简单指令。在汇编语言中，没有像C语言那样明确的控制流，没有传统意义上的函数定义，取而代之的是标签（Labels），用来标识程序的跳转位置。因此，汇编语言被认为是一种非常底层的语言。由于汇编语言与处理器的指令集架构紧密相关，因此它的性能往往比使用高级语言更为高效，但也更加复杂且难以编写和维护。

尽管汇编语言看起来相对原始，但它是所有编译型语言（如C++）的基础。编写的高级语言代码最终都需要被编译成汇编代码，然后处理器才能执行这些指令。因此，理解汇编语言及其工作机制对于掌握计算机系统的工作原理至关重要。通过汇编语言，我们可以直接操控硬件，最大化硬件资源的使用效率，这对于底层系统编程、驱动开发以及性能优化尤为重要。

## 真实汇编代码解析

接下来，我们将通过一个简单的示例来深入了解汇编代码的具体表现形式，并解释汇编代码中各个部分的意义和作用。

![image-20240818102138916]({{ site.baseurl }}/docs/assets/image-20240818102138916.png)

在上图中，代码的上半部分展示了对应的C代码注释，这段代码实现了一个简单的函数，用于累加从1到n的所有数字并返回结果。下半部分则是这段C代码编译成的最基本的汇编代码。值得注意的是，如果你在自己的计算机上编写相同的C代码并编译，可能会看到略有不同的汇编代码。这种差异的主要原因包括编译器的优化策略和编译过程中的具体设置。

> > ### C代码
> >
> > ```c
> > int sum_to(int n) {
> >     int acc = 0;
> >     for (int i = 0; i <= n; i++) {
> >         acc += i;
> >     }
> >     return acc;
> > }
> > ```
> >
> > ### 对应的汇编代码
> >
> > ```
> > .section .text
> > .global sum_to
> > 
> > sum_to:
> >     mv t0, a0       # t0 <- a0
> >     li a0, 0        # a0 <- 0
> > 
> > loop:
> >     add a0, a0, t0  # a0 <- a0 + t0
> >     addi t0, t0, -1 # t0 <- t0 - 1
> >     bnez t0, loop   # if t0 != 0: pc <- loop
> > 
> >     ret
> > ```
> >
> > ### C代码与汇编代码的逐行讲解
> >
> > 1. **C代码：** `int sum_to(int n) {`
> >
> >    - **汇编代码：** `sum_to:`
> >    - 这行C代码定义了一个名为 `sum_to` 的函数，它接收一个整数参数 `n` 并返回一个整数结果。在汇编代码中，`sum_to:` 标签标记了这个函数的入口地址，用于函数调用的跳转。
> >
> > 2. **C代码：** `int acc = 0;`
> >
> >    - **汇编代码：** `li a0, 0        # a0 <- 0`
> >    - C代码初始化变量 `acc` 为0。在汇编代码中，`li a0, 0` 指令将 `a0` 寄存器的值设置为0，这个寄存器在RISC-V调用约定中通常用作函数的返回值或累加器。
> >
> > 3. **C代码：** `for (int i = 0; i <= n; i++) {`
> >
> >    - **汇编代码：** `mv t0, a0       # t0 <- a0`
> >    - 在C代码中，这一行初始化循环变量 `i` 并开始循环。在汇编代码中，`mv t0, a0` 将 `a0` 寄存器中的参数 `n` 复制到 `t0` 寄存器。这个 `t0` 寄存器将用作循环控制变量，表示从 `n` 到 0 的递减计数器。
> >
> > 4. **C代码：** `acc += i;`
> >
> >    - **汇编代码：** 
> >
> >      ```
> >      loop:
> >          add a0, a0, t0  # a0 <- a0 + t0
> >      ```
> >
> >    - 在C代码中，`acc += i` 将当前的 `i` 加到 `acc` 上。在汇编代码中，`add a0, a0, t0` 实现了这个累加操作，将 `t0` 的值加到 `a0` 中（即 `acc` 变量），然后将结果存回 `a0`。
> >
> > 5. **C代码：** `i++`
> >
> >    - **汇编代码：** `addi t0, t0, -1 # t0 <- t0 - 1`
> >    - C代码中 `i++` 增加循环变量 `i`。对应的汇编代码是 `addi t0, t0, -1`，这条指令将 `t0` 的值减1。在这个汇编版本中，循环是从 `n` 到 0 递减的，而不是从 0 到 `n` 递增的。
> >
> > 6. **C代码：** `i <= n`
> >
> >    - **汇编代码：** `bnez t0, loop   # if t0 != 0: pc <- loop`
> >    - 在C代码中，这一部分是循环的条件判断。在汇编代码中，通过 `bnez t0, loop` 指令实现，如果 `t0` 不为0，则跳转回 `loop` 继续循环，否则继续往下执行。这里 `bnez` 是“branch if not equal to zero”的缩写。
> >
> > 7. **C代码：** `return acc;`
> >
> >    - **汇编代码：** `ret`
> >    - C代码返回 `acc` 变量的值。在汇编代码中，`ret` 指令将控制权返回给调用者，同时 `a0` 寄存器中的值（累加和）作为返回值。
> >
> > ### 代码总结
> >
> > - 这个函数的目的是计算从1到 `n` 的累加和，并返回结果。
> > - 汇编代码中使用 `a0` 寄存器来存储累加结果，这也将是函数的返回值。
> > - `t0` 寄存器用于控制循环，初始值为传入的参数 `n`，并在每次迭代中递减。
> > - 汇编代码清晰地展示了C代码中的每一个操作是如何映射到处理器的指令集中的。通过这些汇编指令，处理器能够逐步完成整个累加操作，直至循环结束并返回结果。
> >
> > 汇编代码中的每一行指令都紧密对应着C代码中的某个部分，为我们展示了高级语言在底层的实际执行方式。这种理解对于系统编程、性能优化和深入理解计算机体系结构都非常重要。

### 编译器优化的影响

现代编译器在将C代码编译为汇编代码时，通常会执行各种优化。这些优化旨在提高代码执行效率或减少代码大小，但可能导致你实际编译出的汇编代码与原始C代码的结构不完全对应。例如，编译器可能会识别并删除不再需要的变量，从而简化生成的汇编代码。

在调试过程中，尤其是在使用调试器（如gdb）时，你可能会遇到提示某些变量被优化掉的情况。这是因为编译器在优化过程中可能已经将这些变量从最终的生成代码中移除。这种优化行为虽然提高了运行时的性能，但也增加了调试的复杂性，尤其是在跟踪变量值变化时。

### 汇编代码的逐行解析

图中的汇编代码展示了函数的实际执行流程。让我们逐行解析这些指令：

1. **`mv t0, a0`**：将寄存器`a0`中的值保存到寄存器`t0`中。这里的`a0`通常用于传递函数的第一个参数，因此`t0`现在保存了传入的n值。
2. **`mv a0, zero`**：将寄存器`a0`的值设为0。这一步初始化累加器，用于存储累加结果。
3. **循环部分**：在每次循环中，将`t0`中的数据加到`a0`中，直到`t0`的值变为0。具体来说，循环体内的指令会逐步减少`t0`的值，并将每次减少前的值加到`a0`中，这正是C代码中for循环和累加操作的汇编实现。

这个过程精确地反映了C代码中的逻辑结构。通过这种逐行分析，我们可以更好地理解汇编语言如何映射到处理器的实际操作中。每条指令都是对处理器行为的直接描述，因此理解这些指令可以帮助我们掌握底层代码的执行逻辑。

### 汇编指令的语法与内存区域

> **学生提问**：`.section`，`.global`，`.text`分别是什么意思？

这些汇编指令在汇编代码中具有特定的含义：

- **`.global`**：标识符声明。这个指令声明某个符号为全局符号，意味着这个函数或变量可以被其他文件引用。它通常用于公开函数接口，使得其他模块可以调用此函数。
- **`.text`**：定义代码段（text segment）。这条指令告诉汇编器，接下来的代码应被放置在程序的代码段中。代码段是可执行指令所在的内存区域，在运行时加载到内存中供处理器执行。如果你还记得XV6中的内存布局图，每个进程的page table中都有一个区域是用于存放代码的，这就是text区域。

![image-20240818101912394]({{ site.baseurl }}/docs/assets/image-20240818101912394.png)

这些汇编指令不仅规定了代码如何被组织在内存中，也决定了程序在运行时的布局和可访问性。理解这些指令对于低级别的系统编程至关重要。

### XV6内核中的汇编代码

如果你对操作系统内核感兴趣，建议你查看编译完成后生成的`kernel.asm`文件，该文件包含了XV6内核的完整汇编版本。在这个文件中，你可以看到内核的每一行汇编代码，每行的左侧数字表示该指令在内存中的具体位置。这些地址信息对于调试内核代码非常有用，尤其是在排查内核级别的问题时。

> **学生提问**：`.asm`文件和`.s`文件有什么区别？

`.asm`文件和`.s`文件都是汇编代码文件，但它们在内容和用途上有所不同：

- **`.s`文件**：通常由C代码编译生成，包含纯汇编代码。它的内容较为简洁，直接对应C代码的汇编版本。这个文件是编译过程中的中间产物，直接表示编译器翻译后的代码。
- **`.asm`文件**：除了汇编代码之外，还可能包含大量的额外注释和信息，用于调试和分析。这些注释可以包括每条汇编指令对应的C代码行号、相关的调试符号信息等，使得`.asm`文件在调试和分析时更具参考价值。

在实际的开发过程中，这些文件会提供有价值的参考信息，尤其是在你需要深入理解编译器生成的汇编代码或调试低级别代码时。如果你想知道如何生成`.asm`文件，通常可以在`Makefile`中找到相关的生成步骤。通过理解这些文件的区别，你可以更好地掌握汇编代码的结构和作用。

## 使用GDB调试汇编代码

现在我们回到`sum_to`函数，来看一下如何在GDB中检查这个函数的运行情况。调试汇编代码是理解处理器执行流程的重要一步。在实际开发中，掌握GDB的使用可以帮助我们更有效地查找和解决代码中的问题。

### 启动QEMU和GDB

首先，我们需要启动QEMU虚拟机环境，以便运行XV6操作系统。可以在命令行中通过以下命令启动：

```bash
make qemu-gdb
```

启动QEMU后，我们需要在另一个终端窗口中打开GDB，用于调试内核代码。启动GDB的命令如下：

```bash
riscv64-unknown-elf-gdb
```

![image-20240818103719386]({{ site.baseurl }}/docs/assets/image-20240818103719386.png)

### TUI模式查看源代码

在GDB中，可以通过启用TUI（Text User Interface）模式来查看源代码与汇编代码。输入以下命令启用TUI模式：

```bash
(gdb) tui enable
```

这将打开一个带有源代码展示的窗口，使我们能够直观地看到代码执行情况。

![image-20240818105502522]({{ site.baseurl }}/docs/assets/image-20240818105502522.png)

### 设置断点并开始调试

一旦GDB连接到QEMU并加载了XV6内核代码，你可以在你感兴趣的函数（例如`sum_to`）中设置一个断点。断点会让程序在执行到指定位置时暂停，从而让你检查此时的程序状态。

我们可以在`sum_to`函数的入口处设置一个断点，并继续执行代码直到命中断点：

```bash
(gdb) b sum_to
(gdb) c
```

执行完这些命令后，代码将在断点处停止。GDB窗口的右上角显示的是程序计数器（PC）的当前值，比如`0x800065e2`。

![image-20240818105353548]({{ site.baseurl }}/docs/assets/image-20240818105353548.png)

你可以在`kernel.asm`文件中查找这个地址，确认它是否与`sum_to`函数的起始地址相匹配。

![image-20240818104920383]({{ site.baseurl }}/docs/assets/image-20240818104920383.png)

### 分析汇编指令和寄存器状态

![image-20240818105158157]({{ site.baseurl }}/docs/assets/image-20240818105158157.png)

为了更深入地分析代码，可以在GDB中切换到汇编指令视图：

```bash
(gdb) layout asm
```

这个命令会显示当前函数的所有汇编指令，并高亮显示当前正在执行的指令。你还可以通过以下命令查看所有寄存器的状态

```bash
(gdb) layout reg
```

在寄存器窗口中，你可以观察寄存器的值。例如，`t0`寄存器在执行某条指令后可能会保存`a0`寄存器的值，假设`a0`的值是5，执行指令后`t0`也会变为5。GDB会高亮显示那些值发生变化的寄存器，这使得你可以很容易地跟踪程序执行过程中寄存器的变化。

![image-20240818110448142]({{ site.baseurl }}/docs/assets/image-20240818110448142.png)

### 单步执行代码

在设置好断点并查看寄存器状态后，我们可以使用单步执行命令逐行执行代码：

```bash
(gdb) si
```

通过单步执行，可以逐一检查每一条汇编指令的执行效果，并实时观察寄存器值的变化，直到函数返回。

### 管理断点和寄存器信息

如果在调试过程中设置了多个断点，或者在调试中迷失方向，可以使用以下命令查看所有断点信息：

```bash
(gdb) info breakpoints
```

这个命令会列出所有设置的断点，以及每个断点被命中多少次。

![image-20240818110722221]({{ site.baseurl }}/docs/assets/image-20240818110722221.png)

类似的，可以使用以下命令查看所有寄存器的当前状态：

```bash
(gdb) info reg
```

![image-20240818111137738]({{ site.baseurl }}/docs/assets/image-20240818111137738.png)

### GDB与Tmux的结合使用

在实际操作中，使用`tmux`可以极大地提高你的工作效率。通过`tmux`，你可以在一个终端中管理多个窗口和会话，使得你可以在同一终端中同时查看GDB、QEMU输出以及源代码文件。建议在调试XV6时，充分利用`tmux`的功能来管理你的调试环境。

### 常见问题与快捷指令

在调试过程中，有时你可能会遇到一些问题。比如，当在C代码中设置断点时，GDB会自动在C代码对应的第一条汇编指令处设置断点。如果在同一行C代码中有多个语句，断点会默认设置在该行的第一个语句上。

你也可以使用`layout split`命令同时查看C代码和汇编代码，或使用`layout source`仅查看C代码：

```bash
(gdb) layout split
(gdb) layout source
```

GDB是一个强大的调试工具，通过它我们可以深入理解汇编代码的执行流程，分析代码中的问题。在这节课中，我们重点介绍了如何使用GDB调试汇编代码，查看寄存器状态，管理断点，并结合TUI模式进行代码调试。这些技巧对于理解和掌握低级编程和系统架构至关重要。

## RISC-V汇编与寄存器使用

在前面的内容中，我们已经讨论了汇编语言和RISC-V的基本概念。接下来，我们将进一步探讨RISC-V汇编中的寄存器使用规则，特别是与函数调用和参数传递相关的内容。这部分知识对于你们理解即将到来的实验尤为重要。

### RISC-V寄存器概览

RISC-V架构中有一组固定的寄存器，这些寄存器在执行指令时扮演着关键的角色。寄存器可以被看作是处理器中用于存储数据的快速访问位置。由于汇编代码主要在寄存器上执行操作，因此理解这些寄存器的用途对于编写和调试汇编代码至关重要。

![image-20240818112926277]({{ site.baseurl }}/docs/assets/image-20240818112926277.png)

寄存器不仅仅是CPU执行运算的核心位置，还是在执行函数调用时传递参数和返回值的工具。在RISC-V架构中，有一些寄存器是专门用来处理函数参数的，例如`a0`到`a7`，它们通常用于存储函数的参数或返回值。除此之外，寄存器还有其他特定用途，比如保存返回地址、堆栈指针等。

### 调用约定（Calling Convention）

调用约定是指在函数调用期间，如何在调用者（Caller）和被调用者（Callee）之间传递参数、返回值，以及如何管理寄存器。RISC-V的调用约定中定义了哪些寄存器需要在函数调用前保存，以及如何使用这些寄存器。

寄存器按照它们的用途分为两类：Caller Saved和Callee Saved。

- **Caller Saved寄存器**：调用者在调用函数前需要保存这些寄存器的值，因为被调用的函数可能会修改这些寄存器的内容。`ra`（返回地址寄存器）就是一个典型的Caller Saved寄存器，因为在函数调用过程中，它可能会被覆盖。

- **Callee Saved寄存器**：被调用者在修改这些寄存器的值之前，需要先保存它们，并在函数返回前恢复原值。这样调用者在函数返回后可以继续使用这些寄存器中的数据而不受影响。典型的Callee Saved寄存器包括`sp`（堆栈指针）和`s0-s11`（保存寄存器）。

理解这些寄存器的保存机制对于确保函数调用的正确性非常重要。在编写汇编代码时，使用这些寄存器时必须遵循调用约定，否则可能会导致数据丢失或程序行为异常。

### RISC-V寄存器的实际应用

在实际的RISC-V汇编编程中，寄存器的使用非常灵活。例如，`a0`到`a7`寄存器通常用于传递函数参数。如果一个函数有超过8个参数，剩余的参数则需要通过内存传递。在函数返回时，返回值也会存储在`a0`和`a1`寄存器中。

需要特别注意的是，虽然寄存器操作非常高效，但寄存器的数量有限。因此，当寄存器不够用时，数据可能需要临时存储在内存中。这也是为什么在函数调用过程中，有些寄存器需要保存的原因。

### 调试中的寄存器操作

在调试过程中，理解寄存器的状态和作用是关键。当你使用GDB调试RISC-V汇编代码时，你可以通过查看寄存器的当前状态来了解程序的执行流程。例如，在GDB中查看`ra`寄存器的值可以帮助你确定函数的返回地址，从而更好地理解程序的执行逻辑。

通过GDB中的`layout reg`命令，你可以实时监控所有寄存器的状态，并观察指令执行后寄存器值的变化。这对于定位问题和理解程序执行细节非常有帮助。

### 处理器中的寄存器使用与编译器优化

值得注意的是，在现代编译器中，寄存器的使用并不总是由程序员直接控制的。编译器会根据代码的结构和执行路径自动优化寄存器的使用。这种优化包括寄存器分配、指令调度等，使得生成的汇编代码在执行效率上尽可能高效。

编译器的这些优化会在编译期间决定哪些数据需要存放在寄存器中，哪些需要存放在内存中。因此，编译器优化的结果可能会导致生成的汇编代码与源代码的结构有很大不同。

通过对RISC-V寄存器和调用约定的深入理解，你们将能够更好地编写和调试汇编代码。掌握寄存器的保存机制和调用约定，尤其是在函数调用过程中的应用，对于确保程序的正确性和优化代码执行效率至关重要。在未来的实验中，这些知识将帮助你们更好地理解和实现复杂的操作系统功能。

## 栈与函数调用：深入理解Stack Frame

栈（Stack）在函数调用中扮演着至关重要的角色。它不仅组织了函数调用的执行流程，还确保了函数能够正确返回。下面，我们将深入讨论栈的工作机制，并了解Stack Frame的结构和作用。

### 栈的结构与工作原理

栈是一种后进先出（LIFO, Last In First Out）的数据结构。在函数调用过程中，每当一个新函数被调用时，都会在栈中创建一个新的Stack Frame，这个Frame为该函数的执行提供必要的空间。

栈的使用从高地址向低地址增长。当一个函数调用另一个函数时，新的Stack Frame会被压入栈顶，而当函数返回时，相应的Stack Frame会被弹出，栈指针（SP, Stack Pointer）会调整以反映栈的当前位置。

### Stack Frame的结构

每个Stack Frame通常包含以下几部分：

- **返回地址（Return Address）**：这是调用函数返回后继续执行的位置。它通常位于当前Stack Frame的顶部（也就是栈的高地址部分）。
- **前一个Stack Frame的指针（Previous Frame Pointer）**：这个指针指向调用函数的Stack Frame，确保在函数返回时，能够正确恢复之前的状态。
- **保存的寄存器（Saved Registers）**：这些是函数执行过程中需要保存的寄存器内容，确保它们在函数返回时可以恢复到调用前的状态。
- **本地变量（Local Variables）**：这些是函数中定义的局部变量，存储在当前Stack Frame中。
- **额外的函数参数**：如果函数的参数超过了寄存器能够承载的数量，剩余的参数会被压入栈中。

<img src="{{ site.baseurl }}/docs/assets/image-20240818113958710.png" alt="image-20240818113958710" style="zoom:50%;" />

### 栈指针（SP）与帧指针（FP）

- **栈指针（SP, Stack Pointer）**：指向当前栈的底部（最低的地址）。它表示栈的顶端，即最新的Stack Frame的位置。每当一个函数被调用时，栈指针会移动，以创建新的Stack Frame。

- **帧指针（FP, Frame Pointer）**：指向当前Stack Frame的顶部（最高的地址）。它提供了一种方式来访问当前函数的参数和局部变量，同时也可以通过它访问前一个函数的Stack Frame。

帧指针的作用尤为重要。当函数调用链很深时，帧指针允许程序轻松地返回到调用函数的执行环境，并恢复之前的执行状态。这也是为什么帧指针在调试中被频繁使用的原因。

### Stack Frame的生成与使用

在RISC-V汇编中，Stack Frame的创建和管理通常由编译器自动完成。在汇编代码中，函数调用的过程可以分为三个部分：

1. **函数序言（Function Prologue）**：设置Stack Frame，保存调用者的寄存器状态，调整栈指针。
2. **函数主体（Function Body）**：执行函数的实际逻辑操作。
3. **函数尾声（Function Epilogue）**：恢复调用者的寄存器状态，调整栈指针，返回到调用函数。

在函数序言中，栈指针会向下移动，为新的Stack Frame腾出空间，并将前一个帧指针保存到新的Stack Frame中。函数尾声则相反，它会恢复前一个帧指针，并将栈指针移回到调用前的位置。

通过这种方式，栈确保了函数调用的有序性和执行的正确性，尤其是在复杂的嵌套调用中，栈的管理使得每一个函数调用都有其独立的执行环境。

栈和Stack Frame在函数调用中提供了必要的结构，使得函数可以有序执行，并确保在函数返回时能够正确恢复之前的执行状态。理解栈的工作原理和Stack Frame的结构，对于编写和调试汇编代码至关重要。随着你们在实验中深入操作系统底层功能，这些概念将变得更加重要。

> > 这部分可以参考 6.004 的讲解。

## 函数调用与栈帧的实现：Prologue和Epilogue的作用

在前面我们已经探讨了栈帧的结构和重要性，现在我们通过具体的汇编代码，进一步理解栈帧的创建和销毁过程，以及它们在函数调用中的关键作用。

我们以函数`sum_then_double`为例，来详细看看Prologue和Epilogue（序言和尾声）是如何在函数调用中操作栈帧的。这个汇编代码展示了如何在函数调用中使用栈帧来保存必要的寄存器值，并确保函数能够正确返回。同参见[rCore笔记](https://lzzs.fun/rCore-series/LibOS.html?highlight=prol#%E5%BA%8F%E8%A8%80%E4%B8%8E%E5%B0%BE%E5%A3%B0)

### 代码分析

```
.global sum_then_double    # 声明全局符号 sum_then_double
sum_then_double:           # 函数入口标签
    addi sp, sp, -16       # Prologue: 为栈帧创建16字节的空间
    sd   ra, 0(sp)         # 将返回地址保存到栈帧中
    
    call sum_to            # 调用 sum_to 函数
    li   t0, 2             # 将立即数2加载到 t0 寄存器
    mul  a0, a0, t0        # 将 a0 寄存器的值乘以 2
    
    ld   ra, 0(sp)         # Epilogue: 从栈帧中恢复返回地址
    addi sp, sp, 16        # 恢复栈指针，销毁栈帧
    ret                    # 从函数返回
```

### Prologue 部分

Prologue是函数开始时执行的一段代码，它负责为当前函数创建一个新的栈帧，并保存必要的寄存器值。

- **`addi sp, sp, -16`**: 这是 Prologue 的第一步，它将栈指针 `sp` 向下移动 16 字节，为当前函数创建一个新的栈帧。栈帧用于存储函数调用过程中的临时数据和寄存器值。

- **`sd ra, 0(sp)`**: 这行代码将 `ra` 寄存器（返回地址）保存到栈帧中。`ra` 寄存器保存了调用 `sum_then_double` 函数的返回地址，这样在 `sum_then_double` 执行完毕后，程序能够正确返回到调用该函数的地方。

### 函数主体

函数主体部分执行实际的函数逻辑。在`sum_then_double`中，它调用了另一个函数`sum_to`，并对结果进行了运算。

- **`call sum_to`**: 这行代码调用了 `sum_to` 函数。调用后，`ra` 寄存器将保存 `sum_to` 函数返回时应该跳转的地址，这个地址会覆盖之前的 `ra` 值，因此我们之前将 `ra` 保存到了栈中。

- **`li t0, 2`**: 将立即数 `2` 加载到临时寄存器 `t0` 中。

- **`mul a0, a0, t0`**: 将 `a0` 寄存器的值乘以 `2`，并将结果存回 `a0`。这一步实现了返回值的倍增。

### Epilogue 部分

Epilogue是函数结束时执行的代码，它负责恢复之前保存的寄存器值，并销毁当前栈帧，使程序能够正确返回到调用者。

- **`ld ra, 0(sp)`**: 这是 Epilogue 的第一步，它将之前保存在栈帧中的 `ra` 值恢复到 `ra` 寄存器中，以便函数能够正确返回到调用者。

- **`addi sp, sp, 16`**: 这行代码将栈指针 `sp` 向上移动 16 字节，恢复到调用 `sum_then_double` 之前的状态，从而销毁当前的栈帧。

- **`ret`**: 这行代码让程序跳转到 `ra` 寄存器中保存的返回地址，执行返回操作，跳回到 `sum_then_double` 的调用者处继续执行。

这个函数展示了一个完整的函数调用过程，包括 Prologue（函数开始时创建栈帧的过程）和 Epilogue（函数结束时恢复栈帧的过程）。通过这两个部分，汇编代码确保了函数调用之间的正确执行顺序和返回地址的安全管理。

在执行完 `sum_then_double` 函数后，程序能够正确返回到调用该函数的地方继续执行。这种方式使得函数调用之间的栈帧管理变得非常清晰和安全，有效避免了函数之间的相互干扰。

## 去掉Prologue和Epilogue的影响

如果我们去掉Prologue和Epilogue，那么函数将无法正确保存和恢复`ra`寄存器的值。这意味着当`sum_to`函数返回时，它将跳转到一个错误的位置，导致程序执行不可预测的行为，通常表现为进入无限循环或直接崩溃。

```
.global sum_then_double    # 声明全局符号 sum_then_double
sum_then_double:           # 函数入口标签
    
    call sum_to            # 调用 sum_to 函数
    li   t0, 2             # 将立即数2加载到 t0 寄存器
    mul  a0, a0, t0        # 将 a0 寄存器的值乘以 2

    ret                    # 从函数返回
```

### 调试 `sum_then_double` 函数中的问题

在调试 `sum_then_double` 函数时，我们可以通过设置断点来观察 `ra`（Return Address）寄存器的变化。`ra` 寄存器保存的是函数返回时的地址，也就是函数执行完毕后跳转回的地址。在 `sum_then_double` 函数中，我们可以通过跟踪 `ra` 寄存器的值，来理解函数的调用与返回过程。

1. **设置断点并执行 `sum_then_double` 函数：**

   - 首先，在修改后的 `sum_then_double` 函数中设置断点，然后执行代码，观察执行过程中的寄存器变化。
   - 在进入 `sum_then_double` 函数时，可以看到 `ra` 寄存器的初始值为 `0x80006392`，这指向了调用 `sum_then_double` 的函数 `demo2`。

   ![image-20240818121321146]({{ site.baseurl }}/docs/assets/image-20240818121321146.png)

2. **调用 `sum_to` 函数并查看 `ra` 寄存器：**

   - 当 `sum_then_double` 调用 `sum_to` 函数时，`ra` 寄存器的值被 `sum_to` 函数覆盖。此时 `ra` 的新值为 `0x800065f4`，指向了 `sum_then_double` 函数。这是因为当 `sum_then_double` 调用了 `sum_to` 后，`sum_to` 应该在执行完毕后返回到 `sum_then_double`。

   ![image-20240818121435341]({{ site.baseurl }}/docs/assets/image-20240818121435341.png)

3. **分析返回后的 `ra` 值：**

   - 当 `sum_to` 函数执行完毕并返回时，`ra` 寄存器的值仍然保留在 `sum_to` 返回的地址 `0x800065f4`，而不是 `demo2` 的地址 `0x80006392`。这是因为在 `sum_then_double` 中，我们没有正确恢复 `ra` 寄存器的初始值。
   - 由于 `ra` 寄存器没有恢复到 `sum_then_double` 之前的调用地址，程序会进入一个无限循环，因为返回地址始终指向 `sum_then_double` 自己的代码。

   ![image-20240818121606092]({{ site.baseurl }}/docs/assets/image-20240818121606092.png)

### 问答与解释

1. **为什么在函数开始时要对 `sp` 寄存器减16？**
   - 这是为了在栈上为当前函数分配空间。对 `sp` 寄存器减16意味着栈指针向下移动，腾出16字节的空间用于存储数据。这是为了避免覆盖之前在 `sp` 寄存器位置上的数据。

2. **为什么不减4个字节？**
   - 对 `sp` 减少4字节显然是不够的，因为 `ra` 寄存器是64位的（8字节）。我们通常选择16字节的栈帧大小，因为在很多情况下，还需要额外存储指向上一个栈帧的地址。所以16字节是一个常见的栈帧大小，它提供足够的空间来存储这些必要的信息。

通过调试 `sum_then_double` 函数，我们可以清楚地看到 `ra` 寄存器在函数调用中的重要性。如果我们在函数调用中不正确地保存和恢复 `ra` 的值，那么程序的执行流将会出现问题，可能会导致程序进入无限循环或者崩溃。这也是为什么正确管理栈帧和寄存器的保存与恢复对于程序的正确运行至关重要。

## 调试 `dummymain` 函数及 GDB 调试

在这一部分，我们将深入了解如何使用 GDB 来调试 C 代码，并通过使用一些 GDB 的功能，例如 `info frame`、`backtrace` 等命令来分析调用栈和变量信息。

```c
int dummymain(int argc, char *argv[]) {
    int i = 0;
    for (; i < argc; i++) {
        printf("Argument %d: %s\n", i, argv[i]);
    }
    return 0;
}

void demo4() {
    char *args[] = {"foo", "bar", "baz"};
    int result = dummymain(sizeof(args) / sizeof(args[0]), args);
    if (result < 0) {
        panic("Demo 4");
    }
}

```

### 设置断点并调试 `dummymain` 函数

首先，我们在 `demo4` 函数中调用 `dummymain` 函数，并在 `dummymain` 函数中设置一个断点。通过这个断点，我们可以在执行代码时暂停在 `dummymain` 函数内。

1. **进入 `dummymain` 函数：**

   - 当我们执行代码并停在 `dummymain` 函数的断点处时，可以使用 `info frame` 命令查看当前栈帧的信息。

   ![image-20240818132022621]({{ site.baseurl }}/docs/assets/image-20240818132022621.png)

   ![image-20240818132116685]({{ site.baseurl }}/docs/assets/image-20240818132116685.png)

   - `info frame` 命令显示了当前调用栈的信息，包括：
     - **Stack level 0**: 表示这是调用栈的最底层栈帧。
     - **pc**: 当前的程序计数器（Program Counter），指向正在执行的指令地址。
     - **saved pc**: `demo4` 函数的地址，表明当 `dummymain` 函数执行完毕后，它将返回到 `demo4`。
     - **source language**: 显示当前代码使用的语言，这里是 C 语言。
     - **Arglist at**: 显示函数参数的起始地址及其值。此处显示 `argc=3` 和 `argv` 的地址信息，表明参数被存储在寄存器中。

2. **查看调用栈（Backtrace）：**

   - 使用 `backtrace`（简写 `bt`）命令，可以查看从当前调用栈开始的所有栈帧。这将显示出程序如何进入当前函数的完整路径。

   ![image-20240818132323301]({{ site.baseurl }}/docs/assets/image-20240818132323301.png)

   - `backtrace` 显示了每一个栈帧的函数调用顺序，从最底层的函数开始向上递归。这对于理解函数调用链条非常有帮助。

3. **查看特定栈帧的信息：**

   - 如果你对某个特定的栈帧感兴趣，可以使用 `frame <frame_number>` 命令切换到该栈帧，然后使用 `info frame` 查看详细信息。
   - 例如，如果你对 `syscall` 函数的栈帧感兴趣，可以切换到它的栈帧并查看保存的寄存器、本地变量等信息。

   ![image-20240818132407335]({{ site.baseurl }}/docs/assets/image-20240818132407335.png)

   - 在这个栈帧中，你可以看到更多的详细信息，如保存的寄存器、本地变量等。这些信息对于分析函数调用及其行为非常重要。

### 讨论与回答

1. **为什么编译器会优化 `argc` 或 `argv`？**

   ![image-20240818132205543]({{ site.baseurl }}/docs/assets/image-20240818132205543.png)

   - 这意味着编译器检测到了一种不需要使用这些变量的优化路径，通常是因为这些变量并没有在函数体内直接使用，或者编译器认为可以通过寄存器来实现更高效的操作。编译器的这种优化行为是很常见的，尤其是在启用了优化选项时。

## GDB 的高级技巧

- **条件断点（Conditional Breakpoint）**: 可以在特定条件满足时触发断点。例如，你可以设置一个断点，但只有当某个变量的值等于特定值时，程序才会在断点处暂停。这在调试时非常有用，可以减少不必要的中断。
- **观察点（Watchpoint）**: 用于监视特定变量或内存地址的变化。一旦被监视的变量或内存地址发生变化，程序就会在变化点处暂停。这在调试复杂的状态变化时特别有用。

> ### GDB 的高级技巧示例
>
> 以下是关于使用 GDB（GNU 调试器）的两个高级技巧：**条件断点（Conditional Breakpoint）** 和 **观察点（Watchpoint）**，并通过具体的命令行示例来解释它们的使用方法。
>
> ### 1. **条件断点（Conditional Breakpoint）**
>
> **场景**：假设你有一个循环，并且想在某个变量 `x` 等于 5 时暂停程序执行。你可以设置一个条件断点，只有当 `x == 5` 时才会触发断点。
>
> **示例代码**（`example.c`）：
>
> ```c
> #include <stdio.h>
> 
> void test_function() {
>  int x;
>  for (x = 0; x < 10; x++) {
>      printf("x = %d\n", x);
>  }
> }
> 
> int main() {
>  test_function();
>  return 0;
> }
> ```
>
> **GDB 调试步骤**：
>
> 1. **编译代码**（使用调试信息）：
>
>    ```bash
>    gcc -g -o example example.c
>    ```
>
> 2. **启动 GDB**：
>
>    ```bash
>    gdb ./example
>    ```
>
> 3. **设置断点**：设置一个普通断点在 `test_function` 的 `printf` 语句所在行。
>
>    ```
>    break test_function
>    ```
>
> 4. **添加条件**：为断点添加条件，使其仅在 `x == 5` 时触发。
>
>    ```
>    condition 1 x == 5
>    ```
>
> 5. **运行程序**：
>
>    ```
>    run
>    ```
>
>    当程序执行到 `x == 5` 时，GDB 会暂停程序，并且你可以检查程序的状态（例如查看变量、堆栈等）。在此之前，程序不会因为断点而暂停。
>
> 6. **继续执行或调试**：
>
>    ```
>    continue
>    ```
>
> ### 2. **观察点（Watchpoint）**
>
> **场景**：假设你想监视变量 `x` 的变化，而不仅仅是在特定值时暂停程序。你可以使用观察点，当 `x` 的值发生变化时，GDB 会自动暂停程序。
>
> **GDB 调试步骤**：
>
> 1. **继续使用上述示例代码和已启动的 GDB 会话**。
>
> 2. **设置观察点**：在 `test_function` 中监视变量 `x` 的变化。
>
>    ```
>    watch x
>    ```
>
> 3. **运行程序**：
>
>    ```
>    run
>    ```
>
>    每当 `x` 的值发生变化时，GDB 都会暂停程序，并显示 `x` 的新值。
>
> 4. **观察和调试**：
>    GDB 会输出类似以下的信息：
>
>    ```
>    Hardware watchpoint 2: x
>          
>    Old value = 0
>    New value = 1
>    test_function () at example.c:6
>    6           printf("x = %d\n", x);
>    ```
>
> 5. **继续执行**：
>
>    ```
>    continue
>    ```
>
>    如果继续执行，程序会在每次 `x` 变化时暂停，允许你检查和调试程序的状态。
>
> ### 总结
>
> - **条件断点（Conditional Breakpoint）**：非常适合在特定条件下暂停程序，减少不必要的中断，提升调试效率。
> - **观察点（Watchpoint）**：非常适合监控特定变量或内存地址的变化，特别在需要跟踪复杂状态变化时极为有用。

通过使用 GDB，我们可以深入了解程序的执行流程和调用栈信息，帮助我们更好地调试和理解代码。通过学习和应用 GDB 的这些高级功能，如 `info frame`、`backtrace`、条件断点和观察点等，我们可以更有效地排查问题，提高调试效率。

## Struct 在内存中的结构及其在函数中的使用

在这部分内容中，我们将深入探讨 `struct` 在内存中的组织方式，以及如何在函数中传递和使用 `struct`。`struct` 是 C 语言中非常重要的一个组成部分，它允许我们将不同类型的数据组合在一起，使得数据的管理更加有条理。

### `struct` 在内存中的结构

首先，我们需要了解 `struct` 在内存中的存储结构。一个 `struct` 在内存中被分配到一段连续的内存空间，`struct` 中的每个字段在内存中是相邻存储的。可以将 `struct` 想象成一个数组，不同的是，`struct` 中的元素（字段）可以是不同的数据类型。

例如，假设我们有以下的 `struct` 定义：

```c
struct Person {
    int age;
    float height;
    char name[20];
};
```

在内存中，这个 `struct` 可能会像下图这样组织：

```
+-----------+-----------+-----------------+
|    age    |  height   |      name       |
|  (int)    |  (float)  |     (char[20])  |
+-----------+-----------+-----------------+
```

- `age` 字段存储在 `struct` 的起始位置。
- `height` 字段紧接在 `age` 之后。
- `name` 数组字段占据 `struct` 剩下的内存空间。

由于不同的字段类型可能会占用不同大小的内存，因此 `struct` 的总大小由各字段的大小及其在内存中的排列方式决定。

### `struct` 作为参数传递给函数

我们可以将一个 `struct` 传递给函数。在传递 `struct` 时，通常传递的是该 `struct` 的指针，而不是整个 `struct` 本身。这是因为直接传递一个 `struct` 的副本可能会比较耗费内存和时间，而传递指针则更加高效。

以下是一个 `struct` 被传递给函数的示例代码：

```c
struct Person {
    int age;
    float height;
    char name[20];
};

void printPerson(struct Person *p) {
    printf("Age: %d, Height: %.2f, Name: %s\n", p->age, p->height, p->name);
}
```

在这个例子中，我们定义了一个名为 `Person` 的 `struct`，它有三个字段：`age`、`height` 和 `name`。我们编写了一个函数 `printPerson`，该函数接收一个指向 `Person` 结构体的指针作为参数，并打印出 `Person` 结构体中的信息。

### 调试 `struct` 的使用

当我们在 `printPerson` 函数中设置断点并运行代码时，可以使用 GDB 来检查 `struct` 在函数中的状态：

1. **检查当前栈帧：**  
   在 GDB 中输入 `info frame` 可以查看当前函数的栈帧信息，包括函数的参数和局部变量。例如，打印参数 `p` 可以看到它是一个指向 `Person` 结构体的指针。
   
   ```
   (gdb) info frame
   Stack level 0, frame at 0x7fffffffdbb0:
    pc = 0x4005ed in printPerson; saved pc 0x4006fe
    called by frame at 0x7fffffffdbc0
    source language c.
    Arglist at 0x7fffffffdb90, args: p = 0x7fffffffdab0
   ```

2. **打印 `struct` 的内容：**  
   在 GDB 中，使用 `print *p` 可以查看 `Person` 结构体的具体内容。例如：
   
   ```
   (gdb) print *p
   $1 = {age = 25, height = 175.5, name = "John Doe"}
   ```

   这将显示 `Person` 结构体中的所有字段值，包括 `age`、`height` 和 `name`。

> 提问关于编译器的创建者是谁，是指令集的创建者还是第三方。

通常来说，编译器是由第三方开发和维护的，比如 `gcc` 由 GNU 基金会维护，而 `llvm` 是一个开源项目。指令集的创建者通常会与编译器开发者合作，以确保编译器能够正确地将高级语言编译为对应指令集的汇编代码。例如，RISC-V 的编译器可能会由与该指令集开发团队密切合作的第三方开发。尽管指令集的开发与编译器的开发通常由不同的团队或组织完成，但二者之间的合作至关重要，确保高级语言能够有效地在不同的硬件架构上运行。
