---
layout: page
title: L11 Thread Switching
permalink: /L11
description: "在这节课中，我们将深入探讨线程的概念，以及XV6操作系统如何实现线程切换。线程是现代操作系统中的一个关键组件，它允许计算机在多个任务之间切换，以实现多任务处理和更高的效率。"
nav_order: 11



---



# Lecture 11 - Thread Switching

在这节课中，我们将深入探讨线程的概念，以及XV6操作系统如何实现线程切换。线程是现代操作系统中的一个关键组件，它允许计算机在多个任务之间切换，以实现多任务处理和更高的效率。

### 为什么计算机需要运行多线程？

计算机需要运行多线程有几个主要原因：

1. **多任务处理**：
   - 用户通常希望计算机能同时运行多个任务。例如，在MIT的Athena系统中，多个用户可以同时登录并运行各自的进程。即使在单用户系统（如你的iPhone）上，也有多个进程同时运行，这使得多线程成为必要。

2. **简化编程**：
   - 多线程可以简化程序的结构。在某些情况下，线程可以帮助程序员将代码组织得更加简单和优雅，减少程序的复杂度。例如，在第一个lab中的素数计算部分，通过多个进程，可以更简单地组织代码。

3. **并行运算**：
   - 在多核CPU上，多线程允许程序利用多个CPU核同时运行不同的任务，从而提高处理速度。通过将程序拆分成多个部分并在不同的CPU核上并行运行，可以大幅提升性能。例如，在拥有4个CPU核的系统上，通过4个线程运行程序的不同部分，理论上可以获得4倍的运行速度提升。

## 线程的定义和状态

线程可以看作是程序执行的最小单位。具体来说，线程是一个单一的顺序执行代码的单元。一个线程只占用一个CPU，并且顺序执行指令。在我们的讨论中，线程就是一个串行的执行流。

### 线程的状态

线程在执行过程中，操作系统需要管理其状态，以便在需要时暂停或恢复线程。线程的状态包括以下三个关键部分：

1. **程序计数器（Program Counter, PC）**：
   - PC指向当前线程正在执行的指令。它保存了线程的执行位置，以便在恢复线程时知道从哪里继续执行。

2. **寄存器（Registers）**：
   - 寄存器保存了当前线程的工作变量和临时数据。在多线程环境下，操作系统需要保存和恢复这些寄存器的内容，以确保线程切换时不丢失数据。

3. **栈（Stack）**：
   - 每个线程都有自己的栈，用于保存函数调用的记录和局部变量。栈反映了当前线程的执行路径，并确保函数调用能够正确返回。

### 操作系统中的线程管理

操作系统的线程管理系统负责调度和管理多个线程的运行。随着操作系统启动大量的线程，线程管理系统需要决定如何分配CPU时间给不同的线程，确保所有线程都有机会运行。特别是在多核系统中，操作系统还需要有效地利用多个CPU核来并行运行线程，以最大化系统性能。

### 总结

- **线程的角色**：线程是执行程序代码的基本单元，通过线程，我们可以在计算机上实现多任务处理、简化代码结构，并利用多核CPU实现并行运算。
- **线程的状态管理**：线程的状态包括程序计数器、寄存器和栈，操作系统通过保存和恢复这些状态来实现线程的暂停和恢复。
- **操作系统的线程管理**：操作系统负责管理大量线程的调度和运行，确保多线程程序能够在系统中高效运行。

在接下来的课程中，我们将进一步探讨XV6如何在多个线程之间进行切换，深入了解线程调度的具体实现细节。

## 多线程并行运行的策略

接下来讨论多线程的并行运行策略，特别是如何在单个CPU上实现多个线程的切换。多线程技术对于现代操作系统至关重要，因为它不仅能够在多核处理器上有效利用硬件资源，还能在单核处理器上通过线程切换来模拟并发执行，从而提升系统的响应能力和处理效率。

### 1. 多核处理器上的并行运行

- **多核处理器**：在多核处理器上，多个CPU核可以并行运行多个线程。例如，如果你有4个CPU核，你可以同时运行4个线程，每个线程占用一个CPU核。
- **局限性**：尽管多个CPU核可以并行运行多个线程，但在实际系统中，线程的数量往往远远超过可用的CPU核数量。例如，可能有数千个线程在一个系统中运行，而只有4个CPU核。因此，单靠多核处理器并不能完全解决多线程的并行运行问题。

### 2. 单个CPU上的线程切换

- **线程切换**：当线程的数量超过CPU核的数量时，操作系统需要在单个CPU上实现线程的快速切换。通过保存和恢复线程的状态（如程序计数器、寄存器和栈），操作系统能够在多个线程之间快速切换，使得每个线程都能在一段时间内得到执行。
- **轮换执行**：例如，在一个只有1个CPU的系统中，如果有1000个线程，XV6操作系统会通过线程切换的机制让每个线程依次得到执行。这种机制确保了即使只有一个CPU，系统也能够表现出多线程并行运行的效果。

### 组合策略

现代操作系统通常会结合这两种策略：

- **多核并行**：操作系统会在所有可用的CPU核上并行运行线程。
- **线程切换**：每个CPU核还会在多个线程之间快速切换，从而实现更细粒度的多任务处理。

## 线程的内存共享

线程之间的内存共享是多线程系统中的一个关键问题，不同的操作系统和线程模型对内存共享的处理方式不同。

1. **共享内存的线程**：
   - 线程可以共享同一个地址空间，这意味着一个线程对内存的修改可以被其他线程立即看到。例如，在共享内存模型下，如果一个线程修改了一个变量，其他线程也会立即看到这个变量的变化。
   - 这种情况下，需要使用锁来保护共享资源，以防止竞态条件的发生。

2. **XV6的内存模型**：
   - **内核线程**：XV6的内核线程共享内核的内存空间，每个用户进程都有一个对应的内核线程，用来处理系统调用。这些内核线程共享内存，因此需要使用锁来保证内存的一致性。
   - **用户线程**：在XV6中，每个用户进程都有一个独立的地址空间，并且只有一个线程。因此，XV6中的用户线程之间没有内存共享的问题。

3. **其他系统中的多线程**：
   - **Linux**：与XV6不同，Linux允许一个用户进程中包含多个线程，这些线程共享进程的地址空间。这种模型更为复杂，需要更复杂的线程管理和同步机制。
   - 在Linux中，多个线程可以在多个CPU核上并行执行，且它们共享同一个地址空间，这样的设计使得应用程序可以更好地利用多核处理器的能力。

### 线程与其他多任务技术的对比

尽管线程是实现多任务处理的一个重要工具，但它并不是唯一的选择。还有其他技术也可以支持在一台计算机上运行多个任务：

1. **事件驱动编程（Event-Driven Programming）**：
   - 在事件驱动编程中，程序通过事件循环来处理不同的任务，而不是通过多个线程。事件驱动编程通常用于高效处理I/O密集型任务，特别是在单线程环境中。

2. **状态机（State Machine）**：
   - 状态机通过状态转移来处理不同的任务，而不是依赖多个线程。这种方法在处理复杂的逻辑流程时特别有效，常用于嵌入式系统和实时系统。

虽然这些技术在某些场合可能比线程更为高效，但线程通常是对程序员最友好的多任务实现方法，支持范围广，易于理解和实现。

## 内核中实现线程系统

在内核中实现线程系统面临着几个关键挑战：线程切换的实现、状态的保存与恢复，以及处理运算密集型线程的调度。这些挑战直接影响到操作系统的性能、响应速度以及对多线程应用的支持。接下来，我们详细探讨这些挑战及其解决方案。

### 挑战一：线程间的切换（Scheduling）

**线程调度（Scheduling）**：

- 线程调度是指操作系统决定哪个线程在某个时刻运行的过程。在多核处理器环境中，操作系统会为每个CPU核创建一个线程调度器。调度器负责管理和调度线程，确保每个线程都有机会得到CPU时间片，从而实现公平和高效的资源分配。

**XV6的调度机制**：

- XV6操作系统为每个CPU核分配了一个调度器。调度器根据预定的策略（如时间片轮转调度）来决定哪个线程应该运行，并在线程之间进行切换。

### 挑战二：保存与恢复线程状态

**状态保存与恢复**：

- 当操作系统从一个线程切换到另一个线程时，它必须保存当前线程的状态，并在切换回该线程时恢复这些状态。线程的状态主要包括程序计数器（PC）、CPU寄存器和栈指针等。

**状态保存的关键**：

- 操作系统必须决定哪些线程信息需要保存，以及如何保存这些信息。通常，状态信息会被保存在内核的专用数据结构中，以便在需要时能够快速恢复线程的执行。

**上下文切换**：

- 上下文切换是指从一个线程切换到另一个线程的过程。这个过程包括保存当前线程的状态、恢复目标线程的状态，并更新相关的CPU寄存器。上下文切换虽然开销较大，但对于支持多线程和多任务处理是必要的。

### 挑战三：处理运算密集型线程（Compute-bound Threads）

**运算密集型线程的问题**：

- 运算密集型线程是指那些需要大量CPU时间进行计算的线程，例如计算π的前一百万位。这类线程往往会长时间占用CPU，如果不加以控制，它们可能会导致其他线程得不到执行的机会。

**自愿式调度的局限**：

- 自愿式调度（voluntary scheduling）依赖于线程自己放弃CPU时间片，让出CPU给其他线程。然而，对于运算密集型线程，通常不会自愿让出CPU。这会导致系统中其他线程无法得到执行的机会，严重影响系统的响应速度和用户体验。

**抢占式调度（Pre-emptive Scheduling）**：

- 为了解决运算密集型线程的问题，操作系统采用了抢占式调度。抢占式调度通过定时器中断来强制收回CPU的控制权，即使线程没有主动放弃CPU。
- **定时器中断**：每个CPU核上都有一个定时器，它会定时产生中断信号。当定时器中断发生时，CPU会立即切换到内核模式，触发内核的中断处理程序。内核可以利用这个中断来强制中断当前运行的线程，将CPU时间片交给调度器，让调度器决定下一个要运行的线程。
- **实现流程**：
  1. 定时器中断发生，CPU切换到内核模式。
  2. 内核的中断处理程序保存当前线程的状态。
  3. 中断处理程序自愿让出（yield）CPU，并将控制权交给调度器。
  4. 调度器选择下一个线程并恢复其状态，线程切换完成。

**抢占式调度 vs 自愿式调度**：

- **抢占式调度**：系统强制回收CPU时间片，不依赖线程自愿放弃CPU。这种方式更加公平，能够确保系统中的所有线程都有机会得到执行，避免某些线程长时间占用CPU资源。
- **自愿式调度**：依赖线程自己放弃CPU时间片，通常适用于合作性多任务处理的系统。在这种系统中，线程会在合适的时机主动放弃CPU以避免长时间占用资源。

这些机制确保了XV6能够在多任务环境下高效地管理线程，支持并发操作，并保证系统的公平性和响应性。在后续的课程中，我们将深入探讨XV6中具体的调度和线程切换实现细节。

## 线程调度的实现方式

在XV6和其他操作系统中，线程调度是一项复杂而关键的任务。操作系统必须在多个线程之间分配CPU时间，以确保系统的高效运行。在这个过程中，定时器中断和线程状态管理起着至关重要的作用。

### 1. 抢占式调度（Pre-emptive Scheduling）

- **定时器中断**：在XV6中，定时器中断是强制执行线程调度的关键机制。定时器中断会周期性地打断正在运行的用户进程，将控制权从用户进程转移到内核。这是抢占式调度的核心。
- **转换为可运行状态**：当定时器中断发生时，正在运行的线程会被迫停止执行，并且内核会将其状态从`RUNNING`转换为`RUNNABLE`。这样，该线程不再占用CPU，但它已经准备好在下一个时间片中继续运行。

### 2. 自愿式调度（Voluntary Scheduling）

- **内核代表用户进程**：当内核获得CPU控制权后，它会根据调度算法决定下一个要运行的线程。这时，内核中的线程调度器会自愿地将CPU时间片分配给其他等待运行的线程。这一过程体现了自愿式调度的理念，即线程在合适的时机自愿放弃CPU，允许其他线程获得执行机会。

## 线程状态管理

在执行线程调度时，操作系统需要管理多个线程的状态。每个线程的状态决定了它是否可以运行，以及在何时能够运行。

### 主要的线程状态

1. **RUNNING（正在运行）**：
   - 处于`RUNNING`状态的线程当前正在某个CPU上执行。此时，线程的程序计数器（PC）和寄存器内容保存在CPU的硬件中。

2. **RUNNABLE（可运行）**：
   - 处于`RUNNABLE`状态的线程尚未分配到CPU，但一旦有空闲的CPU，就可以立即运行。此时，线程的程序计数器和寄存器内容已经从CPU中保存到内存中，等待下一次调度时重新加载。

3. **SLEEPING（等待中）**：
   - 处于`SLEEPING`状态的线程正在等待某个事件（例如I/O操作的完成）。它不会被调度器选择运行，直到等待的事件发生。这部分将在后续课程中详细介绍。

### 线程状态的转换

- **从`RUNNING`到`RUNNABLE`的转换**：
  - 当定时器中断发生时，操作系统会将当前`RUNNING`的线程暂停，将其状态转换为`RUNNABLE`。此时，操作系统必须保存该线程的当前状态（包括程序计数器和寄存器内容）到内存中的某个位置。这些信息最初位于CPU的寄存器中，现在被保存到线程控制块（TCB）或类似的数据结构中。

- **从`RUNNABLE`到`RUNNING`的转换**：
  - 当调度器决定重新运行一个`RUNNABLE`线程时，它需要将之前保存的线程状态重新加载到CPU中。具体而言，操作系统会将保存的程序计数器和寄存器内容从内存复制回CPU的寄存器中，然后恢复线程的执行。这一过程称为“上下文切换”。

### 上下文切换的细节

上下文切换是线程调度中的核心操作。它涉及以下几个关键步骤：

1. **保存当前线程状态**：
   - 当线程从`RUNNING`状态转换为`RUNNABLE`状态时，操作系统需要保存当前线程的状态。具体包括：
     - **程序计数器（PC）**：指示当前正在执行的指令地址。
     - **寄存器内容**：包括通用寄存器、栈指针（SP）、基址指针（BP）等，用于保存线程的运行时数据。

2. **切换到新线程**：
   - 调度器选择一个`RUNNABLE`线程运行后，需要将该线程的状态从内存恢复到CPU中。具体操作包括：
     - **恢复程序计数器**：将线程的PC值加载到CPU的PC寄存器中。
     - **恢复寄存器内容**：将寄存器内容从内存恢复到CPU的寄存器中。

3. **恢复执行**：
   - 恢复所有必要的状态后，CPU可以继续执行新的线程，从保存的PC值处继续运行该线程的代码。

## 线程切换的详细流程

### 用户进程与内核线程的关系

1. **用户进程与用户线程**：
   - 用户进程（例如C Compiler、LS、Shell等）在运行时，每个进程实际上对应一个用户线程。这个线程在RISC-V处理器中有自己的程序计数器（PC）和寄存器集。
   - 每个用户进程都有自己的用户栈（User Stack），用于保存函数调用、局部变量等信息。

2. **进入内核空间**：
   - 当用户线程执行系统调用或者发生中断时，线程会从用户空间切换到内核空间。此时，用户线程的状态（包括程序计数器、寄存器等）会被保存到一个叫做`trapframe`的结构中。
   - 接下来，处理器会切换到内核栈上执行代码，这些代码通常包括系统调用处理程序、或中断处理程序。用户线程对应的内核线程开始运行。

### 线程切换过程

### 1. **触发切换**

- **触发条件**：线程切换的触发条件通常包括系统调用的完成、中断（如定时器中断）、进程阻塞、进程终止或优先级调度等。
  - **系统调用完成**：当用户进程发起系统调用并完成时，操作系统可能需要检查是否有更高优先级的任务需要执行，从而决定是否切换到另一个进程。
  - **定时器中断**：定时器中断是实现预抢占式调度的关键机制。当中断发生时，操作系统检查当前进程是否已超出其时间片，如果是，则准备调度其他进程。

### 2. **保存当前线程的内核状态**

- **保存内容**：当XV6决定切换到另一个进程时，当前内核线程的状态必须被保存。这些状态信息包括：
  - **寄存器状态**：所有的通用寄存器（如`eax`、`ebx`等）需要被保存，这些寄存器保存了当前线程的计算状态。
  - **内核栈指针**：内核栈保存了函数调用的上下文、局部变量等。保存当前线程的栈指针（`Kernel Stack Pointer`，通常在`esp`或`rsp`寄存器中）以保证当线程恢复时可以正确使用原来的内核栈。
  - **`context`数据结构**：所有这些信息被保存在一个名为`context`的数据结构中。`context`通常是线程控制块（TCB，Thread Control Block）的一部分，用于保存内核线程的执行状态。

### 3. **加载下一个线程的内核状态**

- **加载内容**：被调度运行的下一个进程的内核线程状态会从之前保存的`context`结构中恢复出来。这个过程涉及：
  - **恢复寄存器状态**：从新的线程的`context`结构中恢复所有寄存器的值，使得CPU能够继续执行新线程的代码。
  - **恢复内核栈指针**：恢复新的线程的内核栈指针，使其指向正确的内核栈位置，确保函数调用和栈帧能够正确进行。

### 4. **恢复用户空间状态**

- **`trapframe`的作用**：当内核线程完成了系统调用或中断处理后，它需要将控制权返回给用户进程。此时，内核将使用`trapframe`来恢复用户态的执行状态。`trapframe`保存了：
  - **程序计数器（PC）**：指向用户进程上次执行的位置。
  - **通用寄存器**：恢复用户态的寄存器状态，包括之前保存的所有寄存器值。
  - **用户栈指针**：恢复用户态的栈指针，以确保用户进程能够正确使用其栈。

## 具体的例子：从CC切换到LS

```plaintext
+------------------------+             +------------------------+
|    User Process (CC)   |             |    User Process (LS)   |
| +--------------------+ |             | +--------------------+ |
| |   User Thread      | |             | |   User Thread      | |
| | +----------------+ | |             | | +----------------+ | |
| | | Program Counter| | |             | | | Program Counter| | |
| | | (PC)           | | |             | | | (PC)           | | |
| | +----------------+ | |             | | +----------------+ | |
| | +----------------+ | |             | | +----------------+ | |
| | |   Registers    | | |             | | |   Registers    | | |
| | +----------------+ | |             | | +----------------+ | |
| +--------------------+ |             | +--------------------+ |
| +--------------------+ |             | +--------------------+ |
| |  User Stack        | |             | |  User Stack        | |
| +--------------------+ |             | +--------------------+ |
+------------------------+             +------------------------+
          |                                ^   Return to User Process
          |   Syscall/Interrupt            |   (Restore User State with Trapframe)
          v                                |   Continue Execution
+--------------------------------------------------------------------+
|                           Kernel Space                             |
| +---------------------+                 +------------------------+ |
| |   Kernel Thread (CC)|                 |   Kernel Thread (LS)   | |
| | +-----------------+ |                 | +--------------------+ | |
| | | Trapframe       | |                 | | Trapframe          | | |
| | | (Save CC's      | |                 | | (Saved LS's        | | |
| | | User State)     | |                 | |  User State)       | | |
| | +-----------------+ |                 | +--------------------+ | |
| | +-----------------+ |  Switch Thread  | +--------------------+ | |
| | | Context         | |  --- and --->   | | Context            | | |
| | | (Save Kernel    | | Continue Execut | | (Load Kernel       | | |
| | |  State)         | |                 | |  State)            | | |
| | +-----------------+ |                 | +--------------------+ | |
| | +-----------------+ |                 | +--------------------+ | |
| | | Kernel Stack    | |                 | | Kernel Stack       | | |
| | +-----------------+ |                 | +--------------------+ | |
| +---------------------+                 +------------------------+ |
+--------------------------------------------------------------------+
```

假设我们有两个用户进程：C Compiler（CC）和LS。当XV6从CC切换到LS时，会发生以下详细步骤，包括对`trapframe`的操作。

### 1. **保存CC的内核线程状态**

- **触发切换**：假设CC进程正在执行某项任务，此时发生了定时器中断，XV6的调度器决定将CPU资源分配给另一个进程LS。

- **保存`trapframe`**：中断发生后，系统立即切换到内核模式，生成并保存当前CC进程的`trapframe`。`trapframe`是一个保存用户态状态的数据结构，包括：

  - 程序计数器（PC）：指向用户进程正在执行的下一条指令。
  - 用户态的所有寄存器（如`eax`、`ebx`等）。
  - 用户栈指针（ESP）：指向当前用户栈的位置。
  - 其他处理器状态（如标志寄存器）。

  通过保存`trapframe`，系统确保当CC进程将来被重新调度时，它可以从中断发生的地方继续执行。

- **保存`context`**：接着，内核会保存CC进程的内核态上下文信息，这包括：

  - 内核态寄存器：保存当前内核线程使用的寄存器值。
  - 内核栈指针：指向当前内核栈的顶端。
  - 这些信息被保存在CC的`context`结构中。

  这样，CC进程的完整执行状态，包括内核态和用户态，均被妥善保存。

### 2. **加载LS的内核线程状态**

- **加载`context`**：XV6调度器决定切换到LS进程。系统首先从LS的`context`结构中恢复该进程的内核态信息。这包括：
  - 恢复内核态寄存器：将LS的寄存器值加载到CPU中。
  - 恢复内核栈指针：设置CPU的栈指针指向LS的内核栈。

- **设置环境**：内核栈指针被恢复后，LS的内核线程能够正确访问其内核栈，并从先前暂停的地方继续执行。这意味着LS的内核线程可以继续处理之前未完成的任务，例如处理中断或系统调用。

### 3. **继续执行LS的内核线程**

- **内核态执行**：LS的内核线程现在获得CPU的控制权，继续执行从上次暂停的地方开始的任务。
  - 如果LS之前被暂停时正在处理中断，那么内核线程会继续执行中断处理程序的剩余部分。
  - 如果LS是在执行系统调用过程中被暂停的，则会继续完成系统调用。

- **准备恢复用户态**：在内核线程处理完所有内核态的任务后，它将准备恢复用户态，继续执行LS的用户代码。

### 4. **恢复LS的用户进程状态**

- **恢复`trapframe`**：内核线程完成任务后，系统将从LS的`trapframe`中恢复用户态信息。这包括：
  - 恢复用户态的程序计数器（PC）：指向LS进程中断前的下一条指令。
  - 恢复用户态寄存器：将`trapframe`中保存的寄存器值恢复到CPU寄存器中。
  - 恢复用户栈指针（ESP）：恢复到LS用户栈的正确位置。

- **切换到用户模式**：在恢复所有用户态信息后，CPU将切换回用户模式，LS进程将继续执行用户代码，从中断发生的地方开始。

通过保存和恢复`trapframe`和`context`，XV6能够在不同进程之间无缝切换。在从CC切换到LS的过程中，系统确保了CC的用户态和内核态都被妥善保存，随后将LS的内核态和用户态恢复到中断前的状态，使其能够继续执行。这一过程确保了进程的正确性和系统的平稳运行。

线程调度器就是在这个过程中起作用的。线程调度器决定哪个线程可以运行，并进行状态切换。我们将在接下来的课程中详细介绍调度器的工作原理和实现。
