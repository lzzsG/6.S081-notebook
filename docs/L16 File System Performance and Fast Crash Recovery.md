---
layout: page
title: L16 File System Performance and Fast Crash Recovery
permalink: /L16
description: "Lecture 16 - File System Performance and Fast Crash Recovery，"
nav_order: 16


---

# Lecture 16 - File System Performance and Fast Crash Recovery

### **回顾：为什么学习日志记录（Logging）？**

日志记录是一种重要且成功的技术，在存储系统的故障恢复中扮演了关键角色。其主要优点包括：

- **广泛应用**：日志记录被广泛应用于数据库、文件系统以及分布式系统中，提供了一种可靠的方法来表示和恢复崩溃前的所有操作。
- **高性能潜力**：尽管在简单系统中，日志记录可能会带来性能开销，但在设计得当的情况下，它能够实现高性能的故障恢复。

> 在文件系统和数据库中，**"Log"（日志）**和**"Journal"（日志）**是同义词。今天的讨论中，我们将使用这两个术语来指代相同的概念。

### **EXT3 文件系统概述**

EXT3 文件系统是基于 EXT2 文件系统的扩展，它通过增加日志记录机制（Journal）来增强系统的可靠性。EXT3 的设计旨在解决像 XV6 文件系统中日志记录的性能问题，同时在故障恢复时提供更好的语义保证。

EXT3 相对于 XV6 的日志记录系统，主要在以下几个方面进行了改进：

- **性能优化**：EXT3 通过更高效的日志记录策略减少了冗余的写操作，从而提高了整体性能。
- **故障恢复语义**：EXT3 的日志记录设计使得系统在崩溃后恢复时能够更好地保证文件系统的一致性和完整性。



## 回顾 XV6 的日志记录系统

XV6 的文件系统在磁盘上由两个主要部分组成：文件系统的主数据区域和日志（Log）区域。

1. **文件系统主数据区域**：
   - 这里包括目录树、文件数据块、inode 表、bitmap 等结构。
   - 目录结构是树状的，以 root 目录为根节点，下层是其他目录和文件。每个文件由多个数据块组成，这些数据块存储了文件的实际内容。
   - 元数据块（metadata block）：如 inode、目录内容、bitmap block，这些块存储文件系统的结构信息。
   - 数据块（data block）：存储文件的实际内容。

2. **日志区域（Log）**：
   - 在磁盘的起始部分，XV6 预留了一段区域作为日志。
   - 日志包括一个 **header block** 和若干 **log data blocks**。 
   - **Header Block**：记录了事务中的写操作，具体表现为这些操作应该修改的文件系统块号（如 block 17、block 29 等）。
   - **Log Data Blocks**：存储了实际的修改数据，这些数据在提交（commit）后被写回到文件系统的主数据区域。

### 文件系统的写操作流程

1. **系统调用与 Block Cache**：
   - 用户程序通过 `write` 或 `create` 系统调用来修改文件系统。
   - 这些写操作首先影响的是内核中的 block cache，也就是磁盘块在内存中的副本。最初的修改仅仅被应用到 block cache 中。

2. **写入日志**：
   - 在系统调用执行完毕之前，内核不会立即将修改写入文件系统，而是会在日志中记录这些操作。
   - `begin_op` 和 `end_op` 标识了事务的开始和结束。在 `begin_op` 和 `end_op` 之间的所有写操作都被暂存于 block cache 中，直到 `end_op` 调用后，才会将这些修改写入到日志区域。

3. **提交日志（Commit Point）**：
   - 当所有写操作都被拷贝到日志区域的 `log data blocks` 后，内核会更新 `header block`，记录这些操作并标记事务为已提交。这个点称为 **提交点（commit point）**。
   - 在提交点之前，如果发生崩溃，日志区域的修改将被视为未发生。在提交点之后，即使发生崩溃，系统也可以通过日志恢复操作，将所有记录的修改应用到文件系统主数据区域。

4. **崩溃恢复**：
   - 在系统崩溃并重启时，恢复软件会检查日志区域的 `header block`。如果 `header block` 中记录了未被应用的操作，恢复软件会将日志区域的 `log data blocks` 中的数据写回到文件系统主数据区域，从而保证文件系统的一致性。
   - 如果 `header block` 显示日志为空（n = 0），则恢复软件什么也不需要做，文件系统处于一致状态。



## XV6 中 `logging` 机制的重要规则和其局限性

在讨论 Linux 的 `ext3` 文件系统之前，先来回顾并理解 XV6 中 `logging` 机制的重要规则和其局限性：

1. **Write-Ahead Rule**（**预写日志规则**）：
   - 这个规则适用于所有 `logging` 系统，包括 XV6 和其他更复杂的系统。其核心思想是：
     * 所有需要具备原子性的写操作必须先写入日志（log），然后才可以将这些操作实际应用到文件系统的主数据区域。
     * 这样做可以确保，如果在中途发生 `crash`，日志中的内容可以用于恢复文件系统，并保持原子性——即这些操作要么全部发生，要么完全不发生。
   - **Write-Ahead Rule** 是实现故障恢复的基础，确保每一个系统调用的文件系统更新都是一致且可恢复的。

2. **Freeing Rule**（释放规则）：
   - 这个规则指出，**在日志中的写操作真正被应用到文件系统的主数据区域之前，日志空间不能被复用**。
   - 也就是说，只有当所有日志中的写操作都已经正确地更新到文件系统后，才能清除日志，并为后续的系统调用提供空间。

### XV6 Logging 流程

`end_op` 函数在每个系统调用结束时会执行以下几个关键步骤：

1. **将修改的块写入日志**：
   - 首先将所有修改的 `block` 写入到日志的 `log data blocks`，包括元数据块和数据块。

2. **更新日志头块（Header Block）**：
   - 更新 `log header`，记录日志中的所有修改操作，以便恢复程序在 `crash` 后知道哪些修改应该被应用。

3. **将日志中的块写回文件系统**：
   - 把 `log data blocks` 中的内容写回到文件系统的主数据区域，确保日志记录的修改在磁盘上生效。

4. **清除日志头块**：
   - 清空 `header block`，将记录的日志条目数清零，以便释放日志空间供下一个事务使用。这是为了避免在日志中写入新的事务时，仍然包含之前的记录，导致错误恢复。

这些步骤确保了在 `crash` 发生时，要么文件系统的所有写操作都已应用，要么没有一个被应用。这样即使系统崩溃，也能保证文件系统的安全和一致性。

### XV6 Logging 的局限性

尽管 XV6 的 `logging` 机制在保障文件系统的安全性方面效果显著，但它有以下明显的性能瓶颈：

1. **同步文件系统调用**：
   - XV6 中每个 `create` 或 `write` 等系统调用必须等到整个 `transaction` 完成之后，才能返回用户空间。这意味着：
     * 在每个 `end_op` 中，需要等待所有写操作（包括更新日志和文件系统）的完成。
     * 由于操作是同步执行的，其他系统调用在此期间无法更新文件系统，导致执行效率非常低下。

2. **每个块写两次**：
   - 在 XV6 中，所有写操作都需要先写入日志（log），然后再写入文件系统的主数据区域。因此，每个块必须写两次：一次是写入日志，一次是实际更新文件系统。
   - 这种两次写操作虽然符合 `write-ahead rule` 的要求，但却显著降低了写操作的效率。

3. **性能问题**：
   - 在使用传统机械硬盘时，由于每个写磁盘操作可能耗费 10 毫秒左右，而每个系统调用涉及多个写操作，这使得文件系统的更新速度非常慢。
   - 即便是在 SSD 上，性能也没有达到真正的高效。这种同步机制严重限制了系统的吞吐量。

### 为什么需要更快的 Logging 系统？

XV6 的 `logging` 系统尽管能保证文件系统的一致性和原子性，但在高性能要求的现代系统中是不可接受的。性能上的瓶颈，尤其是同步文件系统调用和每个块的两次写操作，使得我们需要寻求更高效的 `logging` 方案。这也是 `ext3` 设计 `logging` 系统时考虑的主要因素，它通过优化解决了 XV6 的性能问题。